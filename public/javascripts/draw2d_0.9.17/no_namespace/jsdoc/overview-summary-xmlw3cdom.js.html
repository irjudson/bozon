<!doctype html public "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<html>
<head>
<title>
 Overview
</title>
<link rel ="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script>
function asd() {
	
		parent.document.title="xmlw3cdom.js Overview";
	
}
</script>
</head>
<body bgcolor="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<a name="navbar_top"><!-- --></a>
<table border="0" width="100%" cellpadding="1" cellspacing="0">
<tr>
<td colspan=2 bgcolor="#EEEEFF" class="NavBarCell1">
<a name="navbar_top_firstrow"><!-- --></a>
<table border="0" cellpadding="0" cellspacing="3">
  <tr align="center" valign="top">
  
  
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-summary.html"><font class="NavBarFont1"><b>Overview</b></font></a>&nbsp;</td>
  <td bgcolor="#FFFFFF" class="NavBarCell1Rev">	&nbsp;<font class="NavBarFont1Rev"><b>File</b></font>&nbsp;</td>
  

  <td bgcolor="#FFFFFF" class="NavBarCell1"> 	<font class="NavBarFont1">Class</font>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-tree.html"><font class="NavBarFont1"><b>Tree</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="index-all.html"--><font class="NavBarFont1"><b>Index</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="help-doc.html"><font class="NavBarFont1"><b>Help</b></font></a>&nbsp;</td>
  </tr>
</table>
</td>
<td bgcolor="#EEEEFF" align="right" valign="top">
<em>
<b></b></em>
</td>
</tr>

<tr>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</font></td>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
  <a href="index.html" target="_top"><b>FRAMES</b></a>  &nbsp;
&nbsp;<a href="overview-summary.html" target="_top"><b>NO FRAMES</b></a>
&nbsp;&nbsp;
<script>
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</script>
<noscript>
<a href="allclasses-noframe.html" target=""><b>All Classes</b></a>
</noscript>
</font></td>
</tr>
</table>
<!-- =========== END OF NAVBAR =========== -->

<hr>
<center>
	
	   <h2>xmlw3cdom.js</h2>
	
</center>

	


<h4>Summary</h4>
<p>
	
		No overview generated for 'xmlw3cdom.js'<BR/><BR/>
	
</p>

<hr>



<!-- ========== METHOD SUMMARY =========== -->

	<a name="method_summary"><!-- --></a>
	<table border="1" cellpadding="3" cellspacing="0" width="100%">
		<tr bgcolor="#CCCCFF" class="TableHeadingColor">
			<td colspan=2>
				<font size="+2">
					<b>Method Summary</b>
				</font>
			</td>
		</tr>
	
		
		   <tr bgcolor="white" class="TableRowColor">
		      <td align="right" valign="top" width="1%">
			 <font size="-1">
			    <code>static&nbsp;Object</code>
			 </font>
		      </td>
		      <td>
			 <code>
			    <b>
			       <a href="GLOBALS.html#!s!addClass">addClass</a></b>(classCollectionStr, newClass)
			 </code>
			 <br>
			 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			 
		      </td>
		   </tr>
		
	
	</table>
    <p>

<!-- ========== END METHOD SUMMARY =========== -->


        <pre class="sourceview"><span class="comment">// =========================================================================</span>
<span class="comment">//</span>
<span class="comment">// xmlw3cdom.js - a W3C compliant DOM parser for XML for &lt;SCRIPT&gt;</span>
<span class="comment">//</span>
<span class="comment">// version 3.1</span>
<span class="comment">//</span>
<span class="comment">// =========================================================================</span>
<span class="comment">//</span>
<span class="comment">// Copyright (C) 2002, 2003, 2004 Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au), David Joham (djoham<span class="attrib">@yahoo</span>.com) and Scott Severtson</span>
<span class="comment">//</span>
<span class="comment">// This library is free software; you can redistribute it and/or</span>
<span class="comment">// modify it under the terms of the GNU Lesser General Public</span>
<span class="comment">// License as published by the Free Software Foundation; either</span>
<span class="comment">// version 2.1 of the License, or (at your option) any later version.</span>

<span class="comment">// This library is distributed in the hope that it will be useful,</span>
<span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="comment">// Lesser General Public License for more details.</span>

<span class="comment">// You should have received a copy of the GNU Lesser General Public</span>
<span class="comment">// License along with this library; if not, write to the Free Software</span>
<span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="comment">//</span>
<span class="comment">// visit the XML for &lt;SCRIPT&gt; home page at xmljs.sourceforge.net</span>
<span class="comment">//</span>
<span class="comment">// Contains text (used within comments to methods) from the</span>
<span class="comment">//  XML Path Language (XPath) Version 1.0 W3C Recommendation</span>
<span class="comment">//  Copyright ï¿½ 16 November 1999 World Wide Web Consortium,</span>
<span class="comment">//  (Massachusetts Institute of Technology,</span>
<span class="comment">//  European Research Consortium for Informatics and Mathematics, Keio University).</span>
<span class="comment">//  All Rights Reserved.</span>
<span class="comment">//  (see: http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/)</span>

<span class="comment">/**
 * <span class="attrib">@function</span> addClass - add new className to classCollection
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  classCollectionStr : string - list of existing class names
 *   (separated and top and tailed with '|'s)
 * <span class="attrib">@param</span>  newClass           : string - new class name to add
 *
 * <span class="attrib">@return</span> : string - the new classCollection, with new className appended,
 *   (separated and top and tailed with '|'s)
 */</span>
<span class="reserved">function</span> addClass(classCollectionStr, newClass) {
  <span class="reserved">if</span> (classCollectionStr) {
    <span class="reserved">if</span> (classCollectionStr.indexOf(<span class="literal">"|"</span>+ newClass +<span class="literal">"|"</span>) &lt; 0) {
      classCollectionStr += newClass + <span class="literal">"|"</span>;
    }
  }
  <span class="reserved">else</span> {
    classCollectionStr = <span class="literal">"|"</span>+ newClass + <span class="literal">"|"</span>;
  }

  <span class="reserved">return</span> classCollectionStr;
}

<span class="comment">/**
 * <span class="attrib">@class</span>  DOMException - raised when an operation is impossible to perform
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  code : int - the exception code (one of the DOMException constants)
 */</span>
DOMException = <span class="reserved">function</span>(code) {
  <span class="reserved">this</span>._class = addClass(<span class="reserved">this</span>._class, <span class="literal">"DOMException"</span>);

  <span class="reserved">this</span>.code = code;
};

<span class="comment">// DOMException constants</span>
<span class="comment">// Introduced in DOM Level 1:</span>
DOMException.INDEX_SIZE_ERR                 = 1;
DOMException.DOMSTRING_SIZE_ERR             = 2;
DOMException.HIERARCHY_REQUEST_ERR          = 3;
DOMException.WRONG_DOCUMENT_ERR             = 4;
DOMException.INVALID_CHARACTER_ERR          = 5;
DOMException.NO_DATA_ALLOWED_ERR            = 6;
DOMException.NO_MODIFICATION_ALLOWED_ERR    = 7;
DOMException.NOT_FOUND_ERR                  = 8;
DOMException.NOT_SUPPORTED_ERR              = 9;
DOMException.INUSE_ATTRIBUTE_ERR            = 10;

<span class="comment">// Introduced in DOM Level 2:</span>
DOMException.INVALID_STATE_ERR              = 11;
DOMException.SYNTAX_ERR                     = 12;
DOMException.INVALID_MODIFICATION_ERR       = 13;
DOMException.NAMESPACE_ERR                  = 14;
DOMException.INVALID_ACCESS_ERR             = 15;


<span class="comment">/**
 * <span class="attrib">@class</span>  DOMImplementation - provides a number of methods for performing operations
 *   that are independent of any particular instance of the document object model.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 */</span>
DOMImplementation = <span class="reserved">function</span>() {
  <span class="reserved">this</span>._class = addClass(<span class="reserved">this</span>._class, <span class="literal">"DOMImplementation"</span>);
  <span class="reserved">this</span>._p = null;

  <span class="reserved">this</span>.preserveWhiteSpace = false;  <span class="comment">// by default, ignore whitespace</span>
  <span class="reserved">this</span>.namespaceAware = true;       <span class="comment">// by default, handle namespaces</span>
  <span class="reserved">this</span>.errorChecking  = true;       <span class="comment">// by default, test for exceptions</span>
};


<span class="comment">/**
 * <span class="attrib">@method</span> DOMImplementation.escapeString - escape special characters
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  str : string - The string to be escaped
 *
 * <span class="attrib">@return</span> : string - The escaped string
 */</span>
DOMImplementation.<span class="reserved">prototype</span>.escapeString = <span class="reserved">function</span> DOMNode__escapeString(str) {

  <span class="comment">//the sax processor already has this function. Just wrap it</span>
  <span class="reserved">return</span> __escapeString(str);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMImplementation.unescapeString - unescape special characters
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  str : string - The string to be unescaped
 *
 * <span class="attrib">@return</span> : string - The unescaped string
 */</span>
DOMImplementation.<span class="reserved">prototype</span>.unescapeString = <span class="reserved">function</span> DOMNode__unescapeString(str) {

  <span class="comment">//the sax processor already has this function. Just wrap it</span>
  <span class="reserved">return</span> __unescapeString(str);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMImplementation.hasFeature - Test if the DOM implementation implements a specific feature
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  feature : string - The package name of the feature to test. the legal only values are "XML" and "CORE" (case-insensitive).
 * <span class="attrib">@param</span>  version : string - This is the version number of the package name to test. In Level 1, this is the string "1.0".
 *
 * <span class="attrib">@return</span> : boolean
 */</span>
DOMImplementation.<span class="reserved">prototype</span>.hasFeature = <span class="reserved">function</span> DOMImplementation_hasFeature(feature, version) {

  var ret = false;
  <span class="reserved">if</span> (feature.toLowerCase() == <span class="literal">"xml"</span>) {
    ret = (!version || (version == <span class="literal">"1.0"</span>) || (version == <span class="literal">"2.0"</span>));
  }
  <span class="reserved">else</span> <span class="reserved">if</span> (feature.toLowerCase() == <span class="literal">"core"</span>) {
    ret = (!version || (version == <span class="literal">"2.0"</span>));
  }

  <span class="reserved">return</span> ret;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMImplementation.loadXML - parse XML string
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au), David Joham (djoham<span class="attrib">@yahoo</span>.com) and Scott Severtson
 *
 * <span class="attrib">@param</span>  xmlStr : string - the XML string
 *
 * <span class="attrib">@return</span> : DOMDocument
 */</span>
DOMImplementation.<span class="reserved">prototype</span>.loadXML = <span class="reserved">function</span> DOMImplementation_loadXML(xmlStr) {
  <span class="comment">// create SAX Parser</span>
  var parser;

  try {
    parser = new XMLP(xmlStr);
  }
  catch (e) {
    alert(<span class="literal">"Error Creating the SAX Parser. Did you include xmlsax.js or tinyxmlsax.js in your web page?\nThe SAX parser is needed to populate XML for &lt;SCRIPT&gt;'s W3C DOM Parser with data."</span>);
  }

  <span class="comment">// create DOM Document</span>
  var doc = new DOMDocument(<span class="reserved">this</span>);

  <span class="comment">// populate Document with Parsed Nodes</span>
  <span class="reserved">this</span>._parseLoop(doc, parser);

  <span class="comment">// set parseComplete flag, (Some validation Rules are relaxed if this is false)</span>
  doc._parseComplete = true;

  <span class="reserved">return</span> doc;
};


<span class="comment">/**
 * <span class="attrib">@method</span> DOMImplementation.translateErrCode - convert DOMException Code
 *   to human readable error message;
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  code : int - the DOMException code
 *
 * <span class="attrib">@return</span> : string - the human readbale error message
 */</span>
DOMImplementation.<span class="reserved">prototype</span>.translateErrCode = <span class="reserved">function</span> DOMImplementation_translateErrCode(code) {
  var msg = <span class="literal">""</span>;

  switch (code) {
    case DOMException.INDEX_SIZE_ERR :                <span class="comment">// 1</span>
       msg = <span class="literal">"INDEX_SIZE_ERR: Index out of bounds"</span>;
       break;

    case DOMException.DOMSTRING_SIZE_ERR :            <span class="comment">// 2</span>
       msg = <span class="literal">"DOMSTRING_SIZE_ERR: The resulting string is too long to fit in a DOMString"</span>;
       break;

    case DOMException.HIERARCHY_REQUEST_ERR :         <span class="comment">// 3</span>
       msg = <span class="literal">"HIERARCHY_REQUEST_ERR: The Node can not be inserted at this location"</span>;
       break;

    case DOMException.WRONG_DOCUMENT_ERR :            <span class="comment">// 4</span>
       msg = <span class="literal">"WRONG_DOCUMENT_ERR: The source and the destination Documents are not the same"</span>;
       break;

    case DOMException.INVALID_CHARACTER_ERR :         <span class="comment">// 5</span>
       msg = <span class="literal">"INVALID_CHARACTER_ERR: The string contains an invalid character"</span>;
       break;

    case DOMException.NO_DATA_ALLOWED_ERR :           <span class="comment">// 6</span>
       msg = <span class="literal">"NO_DATA_ALLOWED_ERR: This Node / NodeList does not support data"</span>;
       break;

    case DOMException.NO_MODIFICATION_ALLOWED_ERR :   <span class="comment">// 7</span>
       msg = <span class="literal">"NO_MODIFICATION_ALLOWED_ERR: This object cannot be modified"</span>;
       break;

    case DOMException.NOT_FOUND_ERR :                 <span class="comment">// 8</span>
       msg = <span class="literal">"NOT_FOUND_ERR: The item cannot be found"</span>;
       break;

    case DOMException.NOT_SUPPORTED_ERR :             <span class="comment">// 9</span>
       msg = <span class="literal">"NOT_SUPPORTED_ERR: This implementation does not support function"</span>;
       break;

    case DOMException.INUSE_ATTRIBUTE_ERR :           <span class="comment">// 10</span>
       msg = <span class="literal">"INUSE_ATTRIBUTE_ERR: The Attribute has already been assigned to another Element"</span>;
       break;

<span class="comment">// Introduced in DOM Level 2:</span>
    case DOMException.INVALID_STATE_ERR :             <span class="comment">// 11</span>
       msg = <span class="literal">"INVALID_STATE_ERR: The object is no longer usable"</span>;
       break;

    case DOMException.SYNTAX_ERR :                    <span class="comment">// 12</span>
       msg = <span class="literal">"SYNTAX_ERR: Syntax error"</span>;
       break;

    case DOMException.INVALID_MODIFICATION_ERR :      <span class="comment">// 13</span>
       msg = <span class="literal">"INVALID_MODIFICATION_ERR: Cannot change the type of the object"</span>;
       break;

    case DOMException.NAMESPACE_ERR :                 <span class="comment">// 14</span>
       msg = <span class="literal">"NAMESPACE_ERR: The namespace declaration is incorrect"</span>;
       break;

    case DOMException.INVALID_ACCESS_ERR :            <span class="comment">// 15</span>
       msg = <span class="literal">"INVALID_ACCESS_ERR: The object does not support this function"</span>;
       break;

    default :
       msg = <span class="literal">"UNKNOWN: Unknown Exception Code ("</span>+ code +<span class="literal">")"</span>;
  }

  <span class="reserved">return</span> msg;
}

<span class="comment">/**
 * <span class="attrib">@method</span> DOMImplementation._parseLoop - process SAX events
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au), David Joham (djoham<span class="attrib">@yahoo</span>.com) and Scott Severtson
 *
 * <span class="attrib">@param</span>  doc : DOMDocument - the Document to contain the parsed XML string
 * <span class="attrib">@param</span>  p   : XMLP        - the SAX Parser
 *
 * <span class="attrib">@return</span> : DOMDocument
 */</span>
DOMImplementation.<span class="reserved">prototype</span>._parseLoop = <span class="reserved">function</span> DOMImplementation__parseLoop(doc, p) {
  var iEvt, iNode, iAttr, strName;
  iNodeParent = doc;

  var el_close_count = 0;

  var entitiesList = new Array();
  var textNodesList = new Array();

  <span class="comment">// if namespaceAware, add default namespace</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.namespaceAware) {
    var iNS = doc.createNamespace(<span class="literal">""</span>); <span class="comment">// add the default-default namespace</span>
    iNS.setValue(<span class="literal">"http://www.w3.org/2000/xmlns/"</span>);
    doc._namespaces.setNamedItem(iNS);
  }

  <span class="comment">// loop until SAX parser stops emitting events</span>
  <span class="reserved">while</span>(true) {
    <span class="comment">// get next event</span>
    iEvt = p.next();

    <span class="reserved">if</span> (iEvt == XMLP._ELM_B) {                      <span class="comment">// Begin-Element Event</span>
      var pName = p.getName();                      <span class="comment">// get the Element name</span>
      pName = trim(pName, true, true);              <span class="comment">// strip spaces from Element name</span>

      <span class="reserved">if</span> (!<span class="reserved">this</span>.namespaceAware) {
        iNode = doc.createElement(p.getName());     <span class="comment">// create the Element</span>

        <span class="comment">// add attributes to Element</span>
        <span class="reserved">for</span>(var i = 0; i &lt; p.getAttributeCount(); i++) {
          strName = p.getAttributeName(i);          <span class="comment">// get Attribute name</span>
          iAttr = iNode.getAttributeNode(strName);  <span class="comment">// if Attribute exists, use it</span>

          <span class="reserved">if</span>(!iAttr) {
            iAttr = doc.createAttribute(strName);   <span class="comment">// otherwise create it</span>
          }

          iAttr.setValue(p.getAttributeValue(i));   <span class="comment">// set Attribute value</span>
          iNode.setAttributeNode(iAttr);            <span class="comment">// attach Attribute to Element</span>
        }
      }
      <span class="reserved">else</span> {  <span class="comment">// Namespace Aware</span>
        <span class="comment">// create element (with empty namespaceURI,</span>
        <span class="comment">//  resolve after namespace 'attributes' have been parsed)</span>
        iNode = doc.createElementNS(<span class="literal">""</span>, p.getName());

        <span class="comment">// duplicate ParentNode's Namespace definitions</span>
        iNode._namespaces = iNodeParent._namespaces._cloneNodes(iNode);

        <span class="comment">// add attributes to Element</span>
        <span class="reserved">for</span>(var i = 0; i &lt; p.getAttributeCount(); i++) {
          strName = p.getAttributeName(i);          <span class="comment">// get Attribute name</span>

          <span class="comment">// if attribute is a namespace declaration</span>
          <span class="reserved">if</span> (<span class="reserved">this</span>._isNamespaceDeclaration(strName)) {
            <span class="comment">// parse Namespace Declaration</span>
            var namespaceDec = <span class="reserved">this</span>._parseNSName(strName);

            <span class="reserved">if</span> (strName != <span class="literal">"xmlns"</span>) {
              iNS = doc.createNamespace(strName);   <span class="comment">// define namespace</span>
            }
            <span class="reserved">else</span> {
              iNS = doc.createNamespace(<span class="literal">""</span>);        <span class="comment">// redefine default namespace</span>
            }
            iNS.setValue(p.getAttributeValue(i));   <span class="comment">// set value = namespaceURI</span>

            iNode._namespaces.setNamedItem(iNS);    <span class="comment">// attach namespace to namespace collection</span>
          }
          <span class="reserved">else</span> {  <span class="comment">// otherwise, it is a normal attribute</span>
            iAttr = iNode.getAttributeNode(strName);        <span class="comment">// if Attribute exists, use it</span>

            <span class="reserved">if</span>(!iAttr) {
              iAttr = doc.createAttributeNS(<span class="literal">""</span>, strName);   <span class="comment">// otherwise create it</span>
            }

            iAttr.setValue(p.getAttributeValue(i));         <span class="comment">// set Attribute value</span>
            iNode.setAttributeNodeNS(iAttr);                <span class="comment">// attach Attribute to Element</span>

            <span class="reserved">if</span> (<span class="reserved">this</span>._isIdDeclaration(strName)) {
              iNode.id = p.getAttributeValue(i);    <span class="comment">// cache ID for getElementById()</span>
            }
          }
        }

        <span class="comment">// resolve namespaceURIs for this Element</span>
        <span class="reserved">if</span> (iNode._namespaces.getNamedItem(iNode.prefix)) {
          iNode.namespaceURI = iNode._namespaces.getNamedItem(iNode.prefix).value;
        }

        <span class="comment">//  for this Element's attributes</span>
        <span class="reserved">for</span> (var i = 0; i &lt; iNode.attributes.length; i++) {
          <span class="reserved">if</span> (iNode.attributes.item(i).prefix != <span class="literal">""</span>) {  <span class="comment">// attributes do not have a default namespace</span>
            <span class="reserved">if</span> (iNode._namespaces.getNamedItem(iNode.attributes.item(i).prefix)) {
              iNode.attributes.item(i).namespaceURI = iNode._namespaces.getNamedItem(iNode.attributes.item(i).prefix).value;
            }
          }
        }
      }

      <span class="comment">// if this is the Root Element</span>
      <span class="reserved">if</span> (iNodeParent.nodeType == DOMNode.DOCUMENT_NODE) {
        iNodeParent.documentElement = iNode;        <span class="comment">// register this Element as the Document.documentElement</span>
      }

      iNodeParent.appendChild(iNode);               <span class="comment">// attach Element to parentNode</span>
      iNodeParent = iNode;                          <span class="comment">// descend one level of the DOM Tree</span>
    }

    <span class="reserved">else</span> <span class="reserved">if</span>(iEvt == XMLP._ELM_E) {                  <span class="comment">// End-Element Event</span>
      iNodeParent = iNodeParent.parentNode;         <span class="comment">// ascend one level of the DOM Tree</span>
    }

    <span class="reserved">else</span> <span class="reserved">if</span>(iEvt == XMLP._ELM_EMP) {                <span class="comment">// Empty Element Event</span>
      pName = p.getName();                          <span class="comment">// get the Element name</span>
      pName = trim(pName, true, true);              <span class="comment">// strip spaces from Element name</span>

      <span class="reserved">if</span> (!<span class="reserved">this</span>.namespaceAware) {
        iNode = doc.createElement(pName);           <span class="comment">// create the Element</span>

        <span class="comment">// add attributes to Element</span>
        <span class="reserved">for</span>(var i = 0; i &lt; p.getAttributeCount(); i++) {
          strName = p.getAttributeName(i);          <span class="comment">// get Attribute name</span>
          iAttr = iNode.getAttributeNode(strName);  <span class="comment">// if Attribute exists, use it</span>

          <span class="reserved">if</span>(!iAttr) {
            iAttr = doc.createAttribute(strName);   <span class="comment">// otherwise create it</span>
          }

          iAttr.setValue(p.getAttributeValue(i));   <span class="comment">// set Attribute value</span>
          iNode.setAttributeNode(iAttr);            <span class="comment">// attach Attribute to Element</span>
        }
      }
      <span class="reserved">else</span> {  <span class="comment">// Namespace Aware</span>
        <span class="comment">// create element (with empty namespaceURI,</span>
        <span class="comment">//  resolve after namespace 'attributes' have been parsed)</span>
        iNode = doc.createElementNS(<span class="literal">""</span>, p.getName());

        <span class="comment">// duplicate ParentNode's Namespace definitions</span>
        iNode._namespaces = iNodeParent._namespaces._cloneNodes(iNode);

        <span class="comment">// add attributes to Element</span>
        <span class="reserved">for</span>(var i = 0; i &lt; p.getAttributeCount(); i++) {
          strName = p.getAttributeName(i);          <span class="comment">// get Attribute name</span>

          <span class="comment">// if attribute is a namespace declaration</span>
          <span class="reserved">if</span> (<span class="reserved">this</span>._isNamespaceDeclaration(strName)) {
            <span class="comment">// parse Namespace Declaration</span>
            var namespaceDec = <span class="reserved">this</span>._parseNSName(strName);

            <span class="reserved">if</span> (strName != <span class="literal">"xmlns"</span>) {
              iNS = doc.createNamespace(strName);   <span class="comment">// define namespace</span>
            }
            <span class="reserved">else</span> {
              iNS = doc.createNamespace(<span class="literal">""</span>);        <span class="comment">// redefine default namespace</span>
            }
            iNS.setValue(p.getAttributeValue(i));   <span class="comment">// set value = namespaceURI</span>

            iNode._namespaces.setNamedItem(iNS);    <span class="comment">// attach namespace to namespace collection</span>
          }
          <span class="reserved">else</span> {  <span class="comment">// otherwise, it is a normal attribute</span>
            iAttr = iNode.getAttributeNode(strName);        <span class="comment">// if Attribute exists, use it</span>

            <span class="reserved">if</span>(!iAttr) {
              iAttr = doc.createAttributeNS(<span class="literal">""</span>, strName);   <span class="comment">// otherwise create it</span>
            }

            iAttr.setValue(p.getAttributeValue(i));         <span class="comment">// set Attribute value</span>
            iNode.setAttributeNodeNS(iAttr);                <span class="comment">// attach Attribute to Element</span>

            <span class="reserved">if</span> (<span class="reserved">this</span>._isIdDeclaration(strName)) {
              iNode.id = p.getAttributeValue(i);    <span class="comment">// cache ID for getElementById()</span>
            }
          }
        }

        <span class="comment">// resolve namespaceURIs for this Element</span>
        <span class="reserved">if</span> (iNode._namespaces.getNamedItem(iNode.prefix)) {
          iNode.namespaceURI = iNode._namespaces.getNamedItem(iNode.prefix).value;
        }

        <span class="comment">//  for this Element's attributes</span>
        <span class="reserved">for</span> (var i = 0; i &lt; iNode.attributes.length; i++) {
          <span class="reserved">if</span> (iNode.attributes.item(i).prefix != <span class="literal">""</span>) {  <span class="comment">// attributes do not have a default namespace</span>
            <span class="reserved">if</span> (iNode._namespaces.getNamedItem(iNode.attributes.item(i).prefix)) {
              iNode.attributes.item(i).namespaceURI = iNode._namespaces.getNamedItem(iNode.attributes.item(i).prefix).value;
            }
          }
        }
      }

      <span class="comment">// if this is the Root Element</span>
      <span class="reserved">if</span> (iNodeParent.nodeType == DOMNode.DOCUMENT_NODE) {
        iNodeParent.documentElement = iNode;        <span class="comment">// register this Element as the Document.documentElement</span>
      }

      iNodeParent.appendChild(iNode);               <span class="comment">// attach Element to parentNode</span>
    }
    <span class="reserved">else</span> <span class="reserved">if</span>(iEvt == XMLP._TEXT || iEvt == XMLP._ENTITY) {                   <span class="comment">// TextNode and entity Events</span>
      <span class="comment">// get Text content</span>
      var pContent = p.getContent().substring(p.getContentBegin(), p.getContentEnd());
      
	  <span class="reserved">if</span> (!<span class="reserved">this</span>.preserveWhiteSpace ) {
		<span class="reserved">if</span> (trim(pContent, true, true) == <span class="literal">""</span>) {
			pContent = <span class="literal">""</span>; <span class="comment">//this will cause us not to create the text node below</span>
		}
	  }
	  
      <span class="reserved">if</span> (pContent.length &gt; 0) {                    <span class="comment">// ignore empty TextNodes</span>
        var textNode = doc.createTextNode(pContent);
        iNodeParent.appendChild(textNode); <span class="comment">// attach TextNode to parentNode</span>

        <span class="comment">//the sax parser breaks up text nodes when it finds an entity. For</span>
        <span class="comment">//example hello&amp;lt;there will fire a text, an entity and another text</span>
        <span class="comment">//this sucks for the dom parser because it looks to us in this logic</span>
        <span class="comment">//as three text nodes. I fix this by keeping track of the entity nodes</span>
        <span class="comment">//and when we're done parsing, calling normalize on their parent to</span>
        <span class="comment">//turn the multiple text nodes into one, which is what DOM users expect</span>
        <span class="comment">//the code to do this is at the bottom of this function</span>
        <span class="reserved">if</span> (iEvt == XMLP._ENTITY) {
            entitiesList[entitiesList.length] = textNode;
        }
		<span class="reserved">else</span> {
			<span class="comment">//I can't properly decide how to handle preserve whitespace</span>
			<span class="comment">//until the siblings of the text node are built due to </span>
			<span class="comment">//the entitiy handling described above. I don't know that this</span>
			<span class="comment">//will be all of the text node or not, so trimming is not appropriate</span>
			<span class="comment">//at this time. Keep a list of all the text nodes for now</span>
			<span class="comment">//and we'll process the preserve whitespace stuff at a later time.</span>
			textNodesList[textNodesList.length] = textNode;
		}
      }
    }
    <span class="reserved">else</span> <span class="reserved">if</span>(iEvt == XMLP._PI) {                     <span class="comment">// ProcessingInstruction Event</span>
      <span class="comment">// attach ProcessingInstruction to parentNode</span>
      iNodeParent.appendChild(doc.createProcessingInstruction(p.getName(), p.getContent().substring(p.getContentBegin(), p.getContentEnd())));
    }
    <span class="reserved">else</span> <span class="reserved">if</span>(iEvt == XMLP._CDATA) {                  <span class="comment">// CDATA Event</span>
      <span class="comment">// get CDATA data</span>
      pContent = p.getContent().substring(p.getContentBegin(), p.getContentEnd());

      <span class="reserved">if</span> (!<span class="reserved">this</span>.preserveWhiteSpace) {
        pContent = trim(pContent, true, true);      <span class="comment">// trim whitespace</span>
        pContent.replace(/ +/g, <span class="literal">' '</span>);               <span class="comment">// collapse multiple spaces to 1 space</span>
      }

      <span class="reserved">if</span> (pContent.length &gt; 0) {                    <span class="comment">// ignore empty CDATANodes</span>
        iNodeParent.appendChild(doc.createCDATASection(pContent)); <span class="comment">// attach CDATA to parentNode</span>
      }
    }
    <span class="reserved">else</span> <span class="reserved">if</span>(iEvt == XMLP._COMMENT) {                <span class="comment">// Comment Event</span>
      <span class="comment">// get COMMENT data</span>
      var pContent = p.getContent().substring(p.getContentBegin(), p.getContentEnd());

      <span class="reserved">if</span> (!<span class="reserved">this</span>.preserveWhiteSpace) {
        pContent = trim(pContent, true, true);      <span class="comment">// trim whitespace</span>
        pContent.replace(/ +/g, <span class="literal">' '</span>);               <span class="comment">// collapse multiple spaces to 1 space</span>
      }

      <span class="reserved">if</span> (pContent.length &gt; 0) {                    <span class="comment">// ignore empty CommentNodes</span>
        iNodeParent.appendChild(doc.createComment(pContent));  <span class="comment">// attach Comment to parentNode</span>
      }
    }
    <span class="reserved">else</span> <span class="reserved">if</span>(iEvt == XMLP._DTD) {                    <span class="comment">// ignore DTD events</span>
    }
    <span class="reserved">else</span> <span class="reserved">if</span>(iEvt == XMLP._ERROR) {
      throw(new DOMException(DOMException.SYNTAX_ERR));
      <span class="comment">// alert("Fatal Error: " + p.getContent() + "\nLine: " + p.getLineNumber() + "\nColumn: " + p.getColumnNumber() + "\n");</span>
      <span class="comment">// break;</span>
    }
    <span class="reserved">else</span> <span class="reserved">if</span>(iEvt == XMLP._NONE) {                   <span class="comment">// no more events</span>
      <span class="reserved">if</span> (iNodeParent == doc) {                     <span class="comment">// confirm that we have recursed back up to root</span>
        break;
      }
      <span class="reserved">else</span> {
        throw(new DOMException(DOMException.SYNTAX_ERR));  <span class="comment">// one or more Tags were not closed properly</span>
      }
    }
  }

  <span class="comment">//normalize any entities in the DOM to a single textNode</span>
  var intCount = entitiesList.length;
  <span class="reserved">for</span> (intLoop = 0; intLoop &lt; intCount; intLoop++) {
      var entity = entitiesList[intLoop];
      <span class="comment">//its possible (if for example two entities were in the</span>
      <span class="comment">//same domnode, that the normalize on the first entitiy</span>
      <span class="comment">//will remove the parent for the second. Only do normalize</span>
      <span class="comment">//if I can find a parent node</span>
      var parentNode = entity.getParentNode();
      <span class="reserved">if</span> (parentNode) {
          parentNode.normalize();
		  
		  <span class="comment">//now do whitespace (if necessary)</span>
		  <span class="comment">//it was not done for text nodes that have entities</span>
		  <span class="reserved">if</span>(!<span class="reserved">this</span>.preserveWhiteSpace) {
		  		var children = parentNode.getChildNodes();
				var intCount2 = children.getLength();
				<span class="reserved">for</span> ( intLoop2 = 0; intLoop2 &lt; intCount2; intLoop2++) {
					var child = children.item(intLoop2);
					<span class="reserved">if</span> (child.getNodeType() == DOMNode.TEXT_NODE) {
						var childData = child.getData();
						childData = trim(childData, true, true);
						childData.replace(/ +/g, <span class="literal">' '</span>);
						child.setData(childData);
					}
				}
		  }
      }
  }
  
  <span class="comment">//do the preserve whitespace processing on the rest of the text nodes</span>
  <span class="comment">//It's possible (due to the processing above) that the node will have been</span>
  <span class="comment">//removed from the tree. Only do whitespace checking if parentNode is not null.</span>
  <span class="comment">//This may duplicate the whitespace processing for some nodes that had entities in them</span>
  <span class="comment">//but there's no way around that</span>
  <span class="reserved">if</span> (!<span class="reserved">this</span>.preserveWhiteSpace) {
  	var intCount = textNodesList.length;
	<span class="reserved">for</span> (intLoop = 0; intLoop &lt; intCount; intLoop++) {
		var node = textNodesList[intLoop];
		<span class="reserved">if</span> (node.getParentNode() != null) {
			var nodeData = node.getData();
			nodeData = trim(nodeData, true, true);
			nodeData.replace(/ +/g, <span class="literal">' '</span>);
			node.setData(nodeData);
		}
	}
  
  }
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMImplementation._isNamespaceDeclaration - Return true, if attributeName is a namespace declaration
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  attributeName : string - the attribute name
 *
 * <span class="attrib">@return</span> : boolean
 */</span>
DOMImplementation.<span class="reserved">prototype</span>._isNamespaceDeclaration = <span class="reserved">function</span> DOMImplementation__isNamespaceDeclaration(attributeName) {
  <span class="comment">// test if attributeName is 'xmlns'</span>
  <span class="reserved">return</span> (attributeName.indexOf(<span class="literal">'xmlns'</span>) &gt; -1);
}

<span class="comment">/**
 * <span class="attrib">@method</span> DOMImplementation._isIdDeclaration - Return true, if attributeName is an id declaration
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  attributeName : string - the attribute name
 *
 * <span class="attrib">@return</span> : boolean
 */</span>
DOMImplementation.<span class="reserved">prototype</span>._isIdDeclaration = <span class="reserved">function</span> DOMImplementation__isIdDeclaration(attributeName) {
  <span class="comment">// test if attributeName is 'id' (case insensitive)</span>
  <span class="reserved">return</span> (attributeName.toLowerCase() == <span class="literal">'id'</span>);
}

<span class="comment">/**
 * <span class="attrib">@method</span> DOMImplementation._isValidName - Return true,
 *   if name contains no invalid characters
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  name : string - the candidate name
 *
 * <span class="attrib">@return</span> : boolean
 */</span>
DOMImplementation.<span class="reserved">prototype</span>._isValidName = <span class="reserved">function</span> DOMImplementation__isValidName(name) {
  <span class="comment">// test if name contains only valid characters</span>
  <span class="reserved">return</span> name.match(re_validName);
}
re_validName = /^[a-zA-Z_:][a-zA-Z0-9\.\-_:]*$/;

<span class="comment">/**
 * <span class="attrib">@method</span> DOMImplementation._isValidString - Return true, if string does not contain any illegal chars
 *  All of the characters 0 through 31 and character 127 are nonprinting control characters.
 *  With the exception of characters 09, 10, and 13, (Ox09, Ox0A, and Ox0D)
 *  Note: different from _isValidName in that ValidStrings may contain spaces
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  name : string - the candidate string
 *
 * <span class="attrib">@return</span> : boolean
 */</span>
DOMImplementation.<span class="reserved">prototype</span>._isValidString = <span class="reserved">function</span> DOMImplementation__isValidString(name) {
  <span class="comment">// test that string does not contains invalid characters</span>
  <span class="reserved">return</span> (name.search(re_invalidStringChars) &lt; 0);
}
re_invalidStringChars = /\x01|\x02|\x03|\x04|\x05|\x06|\x07|\x08|\x0B|\x0C|\x0E|\x0F|\x10|\x11|\x12|\x13|\x14|\x15|\x16|\x17|\x18|\x19|\x1A|\x1B|\x1C|\x1D|\x1E|\x1F|\x7F/

<span class="comment">/**
 * <span class="attrib">@method</span> DOMImplementation._parseNSName - parse the namespace name.
 *  if there is no colon, the
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  qualifiedName : string - The qualified name
 *
 * <span class="attrib">@return</span> : NSName - [
 *                     .prefix        : string - The prefix part of the qname
 *                     .namespaceName : string - The namespaceURI part of the qname
 *                    ]
 */</span>
DOMImplementation.<span class="reserved">prototype</span>._parseNSName = <span class="reserved">function</span> DOMImplementation__parseNSName(qualifiedName) {
  var resultNSName = new Object();

  resultNSName.prefix          = qualifiedName;  <span class="comment">// unless the qname has a namespaceName, the prefix is the entire String</span>
  resultNSName.namespaceName   = <span class="literal">""</span>;

  <span class="comment">// split on ':'</span>
  delimPos = qualifiedName.indexOf(<span class="literal">':'</span>);

  <span class="reserved">if</span> (delimPos &gt; -1) {
    <span class="comment">// get prefix</span>
    resultNSName.prefix        = qualifiedName.substring(0, delimPos);

    <span class="comment">// get namespaceName</span>
    resultNSName.namespaceName = qualifiedName.substring(delimPos +1, qualifiedName.length);
  }

  <span class="reserved">return</span> resultNSName;
}

<span class="comment">/**
 * <span class="attrib">@method</span> DOMImplementation._parseQName - parse the qualified name
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  qualifiedName : string - The qualified name
 *
 * <span class="attrib">@return</span> : QName
 */</span>
DOMImplementation.<span class="reserved">prototype</span>._parseQName = <span class="reserved">function</span> DOMImplementation__parseQName(qualifiedName) {
  var resultQName = new Object();

  resultQName.localName = qualifiedName;  <span class="comment">// unless the qname has a prefix, the local name is the entire String</span>
  resultQName.prefix    = <span class="literal">""</span>;

  <span class="comment">// split on ':'</span>
  delimPos = qualifiedName.indexOf(<span class="literal">':'</span>);

  <span class="reserved">if</span> (delimPos &gt; -1) {
    <span class="comment">// get prefix</span>
    resultQName.prefix    = qualifiedName.substring(0, delimPos);

    <span class="comment">// get localName</span>
    resultQName.localName = qualifiedName.substring(delimPos +1, qualifiedName.length);
  }

  <span class="reserved">return</span> resultQName;
}

<span class="comment">/**
 * <span class="attrib">@class</span>  DOMNodeList - provides the abstraction of an ordered collection of nodes
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  ownerDocument : DOMDocument - the ownerDocument
 * <span class="attrib">@param</span>  parentNode    : DOMNode - the node that the DOMNodeList is attached to (or null)
 */</span>
DOMNodeList = <span class="reserved">function</span>(ownerDocument, parentNode) {
  <span class="reserved">this</span>._class = addClass(<span class="reserved">this</span>._class, <span class="literal">"DOMNodeList"</span>);
  <span class="reserved">this</span>._nodes = new Array();

  <span class="reserved">this</span>.length = 0;
  <span class="reserved">this</span>.parentNode = parentNode;
  <span class="reserved">this</span>.ownerDocument = ownerDocument;

  <span class="reserved">this</span>._readonly = false;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNodeList.getLength - Java style gettor for .length
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : int
 */</span>
DOMNodeList.<span class="reserved">prototype</span>.getLength = <span class="reserved">function</span> DOMNodeList_getLength() {
  <span class="reserved">return</span> <span class="reserved">this</span>.length;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNodeList.item - Returns the indexth item in the collection.
 *   If index is greater than or equal to the number of nodes in the list, this returns null.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  index : int - Index into the collection.
 *
 * <span class="attrib">@return</span> : DOMNode - The node at the indexth position in the NodeList, or null if that is not a valid index
 */</span>
DOMNodeList.<span class="reserved">prototype</span>.item = <span class="reserved">function</span> DOMNodeList_item(index) {
  var ret = null;

  <span class="reserved">if</span> ((index &gt;= 0) &amp;&amp; (index &lt; <span class="reserved">this</span>._nodes.length)) { <span class="comment">// bounds check</span>
    ret = <span class="reserved">this</span>._nodes[index];                    <span class="comment">// return selected Node</span>
  }

  <span class="reserved">return</span> ret;                                    <span class="comment">// if the index is out of bounds, default value null is returned</span>
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNodeList._findItemIndex - find the item index of the node with the specified internal id
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  id : int - unique internal id
 *
 * <span class="attrib">@return</span> : int
 */</span>
DOMNodeList.<span class="reserved">prototype</span>._findItemIndex = <span class="reserved">function</span> DOMNodeList__findItemIndex(id) {
  var ret = -1;

  <span class="comment">// test that id is valid</span>
  <span class="reserved">if</span> (id &gt; -1) {
    <span class="reserved">for</span> (var i=0; i&lt;<span class="reserved">this</span>._nodes.length; i++) {
      <span class="comment">// compare id to each node's _id</span>
      <span class="reserved">if</span> (<span class="reserved">this</span>._nodes[i]._id == id) {            <span class="comment">// found it!</span>
        ret = i;
        break;
      }
    }
  }

  <span class="reserved">return</span> ret;                                    <span class="comment">// if node is not found, default value -1 is returned</span>
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNodeList._insertBefore - insert the specified Node into the NodeList before the specified index
 *   Used by DOMNode.insertBefore(). Note: DOMNode.insertBefore() is responsible for Node Pointer surgery
 *   DOMNodeList._insertBefore() simply modifies the internal data structure (Array).
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  newChild      : DOMNode - the Node to be inserted
 * <span class="attrib">@param</span>  refChildIndex : int     - the array index to insert the Node before
 */</span>
DOMNodeList.<span class="reserved">prototype</span>._insertBefore = <span class="reserved">function</span> DOMNodeList__insertBefore(newChild, refChildIndex) {
  <span class="reserved">if</span> ((refChildIndex &gt;= 0) &amp;&amp; (refChildIndex &lt; <span class="reserved">this</span>._nodes.length)) { <span class="comment">// bounds check</span>
    <span class="comment">// get array containing children prior to refChild</span>
    var tmpArr = new Array();
    tmpArr = <span class="reserved">this</span>._nodes.slice(0, refChildIndex);

    <span class="reserved">if</span> (newChild.nodeType == DOMNode.DOCUMENT_FRAGMENT_NODE) {  <span class="comment">// node is a DocumentFragment</span>
      <span class="comment">// append the children of DocumentFragment</span>
      tmpArr = tmpArr.concat(newChild.childNodes._nodes);
    }
    <span class="reserved">else</span> {
      <span class="comment">// append the newChild</span>
      tmpArr[tmpArr.length] = newChild;
    }

    <span class="comment">// append the remaining original children (including refChild)</span>
    <span class="reserved">this</span>._nodes = tmpArr.concat(<span class="reserved">this</span>._nodes.slice(refChildIndex));

    <span class="reserved">this</span>.length = <span class="reserved">this</span>._nodes.length;            <span class="comment">// update length</span>
  }
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNodeList._replaceChild - replace the specified Node in the NodeList at the specified index
 *   Used by DOMNode.replaceChild(). Note: DOMNode.replaceChild() is responsible for Node Pointer surgery
 *   DOMNodeList._replaceChild() simply modifies the internal data structure (Array).
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  newChild      : DOMNode - the Node to be inserted
 * <span class="attrib">@param</span>  refChildIndex : int     - the array index to hold the Node
 */</span>
DOMNodeList.<span class="reserved">prototype</span>._replaceChild = <span class="reserved">function</span> DOMNodeList__replaceChild(newChild, refChildIndex) {
  var ret = null;

  <span class="reserved">if</span> ((refChildIndex &gt;= 0) &amp;&amp; (refChildIndex &lt; <span class="reserved">this</span>._nodes.length)) { <span class="comment">// bounds check</span>
    ret = <span class="reserved">this</span>._nodes[refChildIndex];            <span class="comment">// preserve old child for return</span>

    <span class="reserved">if</span> (newChild.nodeType == DOMNode.DOCUMENT_FRAGMENT_NODE) {  <span class="comment">// node is a DocumentFragment</span>
      <span class="comment">// get array containing children prior to refChild</span>
      var tmpArr = new Array();
      tmpArr = <span class="reserved">this</span>._nodes.slice(0, refChildIndex);

      <span class="comment">// append the children of DocumentFragment</span>
      tmpArr = tmpArr.concat(newChild.childNodes._nodes);

      <span class="comment">// append the remaining original children (not including refChild)</span>
      <span class="reserved">this</span>._nodes = tmpArr.concat(<span class="reserved">this</span>._nodes.slice(refChildIndex + 1));
    }
    <span class="reserved">else</span> {
      <span class="comment">// simply replace node in array (links between Nodes are made at higher level)</span>
      <span class="reserved">this</span>._nodes[refChildIndex] = newChild;
    }
  }

  <span class="reserved">return</span> ret;                                   <span class="comment">// return replaced node</span>
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNodeList._removeChild - remove the specified Node in the NodeList at the specified index
 *   Used by DOMNode.removeChild(). Note: DOMNode.removeChild() is responsible for Node Pointer surgery
 *   DOMNodeList._replaceChild() simply modifies the internal data structure (Array).
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  refChildIndex : int - the array index holding the Node to be removed
 */</span>
DOMNodeList.<span class="reserved">prototype</span>._removeChild = <span class="reserved">function</span> DOMNodeList__removeChild(refChildIndex) {
  var ret = null;

  <span class="reserved">if</span> (refChildIndex &gt; -1) {                              <span class="comment">// found it!</span>
    ret = <span class="reserved">this</span>._nodes[refChildIndex];                    <span class="comment">// return removed node</span>

    <span class="comment">// rebuild array without removed child</span>
    var tmpArr = new Array();
    tmpArr = <span class="reserved">this</span>._nodes.slice(0, refChildIndex);
    <span class="reserved">this</span>._nodes = tmpArr.concat(<span class="reserved">this</span>._nodes.slice(refChildIndex +1));

    <span class="reserved">this</span>.length = <span class="reserved">this</span>._nodes.length;            <span class="comment">// update length</span>
  }

  <span class="reserved">return</span> ret;                                   <span class="comment">// return removed node</span>
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNodeList._appendChild - append the specified Node to the NodeList
 *   Used by DOMNode.appendChild(). Note: DOMNode.appendChild() is responsible for Node Pointer surgery
 *   DOMNodeList._appendChild() simply modifies the internal data structure (Array).
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  newChild      : DOMNode - the Node to be inserted
 */</span>
DOMNodeList.<span class="reserved">prototype</span>._appendChild = <span class="reserved">function</span> DOMNodeList__appendChild(newChild) {

  <span class="reserved">if</span> (newChild.nodeType == DOMNode.DOCUMENT_FRAGMENT_NODE) {  <span class="comment">// node is a DocumentFragment</span>
    <span class="comment">// append the children of DocumentFragment</span>
    <span class="reserved">this</span>._nodes = <span class="reserved">this</span>._nodes.concat(newChild.childNodes._nodes);
  }
  <span class="reserved">else</span> {
    <span class="comment">// simply add node to array (links between Nodes are made at higher level)</span>
    <span class="reserved">this</span>._nodes[<span class="reserved">this</span>._nodes.length] = newChild;
  }

  <span class="reserved">this</span>.length = <span class="reserved">this</span>._nodes.length;              <span class="comment">// update length</span>
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNodeList._cloneNodes - Returns a NodeList containing clones of the Nodes in this NodeList
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  deep : boolean - If true, recursively clone the subtree under each of the nodes;
 *   if false, clone only the nodes themselves (and their attributes, if it is an Element).
 * <span class="attrib">@param</span>  parentNode : DOMNode - the new parent of the cloned NodeList
 *
 * <span class="attrib">@return</span> : DOMNodeList - NodeList containing clones of the Nodes in this NodeList
 */</span>
DOMNodeList.<span class="reserved">prototype</span>._cloneNodes = <span class="reserved">function</span> DOMNodeList__cloneNodes(deep, parentNode) {
  var cloneNodeList = new DOMNodeList(<span class="reserved">this</span>.ownerDocument, parentNode);

  <span class="comment">// create list containing clones of each child</span>
  <span class="reserved">for</span> (var i=0; i &lt; <span class="reserved">this</span>._nodes.length; i++) {
    cloneNodeList._appendChild(<span class="reserved">this</span>._nodes[i].cloneNode(deep));
  }

  <span class="reserved">return</span> cloneNodeList;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNodeList.toString - Serialize this NodeList into an XML string
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au) and David Joham (djoham<span class="attrib">@yahoo</span>.com)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMNodeList.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span> DOMNodeList_toString() {
  var ret = <span class="literal">""</span>;

  <span class="comment">// create string containing the concatenation of the string values of each child</span>
  <span class="reserved">for</span> (var i=0; i &lt; <span class="reserved">this</span>.length; i++) {
    ret += <span class="reserved">this</span>._nodes[i].toString();
  }

  <span class="reserved">return</span> ret;
};

<span class="comment">/**
 * <span class="attrib">@class</span>  DOMNamedNodeMap - used to represent collections of nodes that can be accessed by name
 *  typically a set of Element attributes
 *
 * <span class="attrib">@extends</span> DOMNodeList - note W3C spec says that this is not the case,
 *   but we need an item() method identicle to DOMNodeList's, so why not?
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  ownerDocument : DOMDocument - the ownerDocument
 * <span class="attrib">@param</span>  parentNode    : DOMNode - the node that the DOMNamedNodeMap is attached to (or null)
 */</span>
DOMNamedNodeMap = <span class="reserved">function</span>(ownerDocument, parentNode) {
  <span class="reserved">this</span>._class = addClass(<span class="reserved">this</span>._class, <span class="literal">"DOMNamedNodeMap"</span>);
  <span class="reserved">this</span>.DOMNodeList = DOMNodeList;
  <span class="reserved">this</span>.DOMNodeList(ownerDocument, parentNode);
};
DOMNamedNodeMap.<span class="reserved">prototype</span> = new DOMNodeList;

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamedNodeMap.getNamedItem - Retrieves a node specified by name
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  name : string - Name of a node to retrieve
 *
 * <span class="attrib">@return</span> : DOMNode
 */</span>
DOMNamedNodeMap.<span class="reserved">prototype</span>.getNamedItem = <span class="reserved">function</span> DOMNamedNodeMap_getNamedItem(name) {
  var ret = null;

  <span class="comment">// test that Named Node exists</span>
  var itemIndex = <span class="reserved">this</span>._findNamedItemIndex(name);

  <span class="reserved">if</span> (itemIndex &gt; -1) {                          <span class="comment">// found it!</span>
    ret = <span class="reserved">this</span>._nodes[itemIndex];                <span class="comment">// return NamedNode</span>
  }

  <span class="reserved">return</span> ret;                                    <span class="comment">// if node is not found, default value null is returned</span>
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamedNodeMap.setNamedItem - Adds a node using its nodeName attribute
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  arg : DOMNode - A node to store in a named node map.
 *   The node will later be accessible using the value of the nodeName attribute of the node.
 *   If a node with that name is already present in the map, it is replaced by the new one.
 *
 * <span class="attrib">@throws</span> : DOMException - WRONG_DOCUMENT_ERR: Raised if arg was created from a different document than the one that created this map.
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this NamedNodeMap is readonly.
 * <span class="attrib">@throws</span> : DOMException - INUSE_ATTRIBUTE_ERR: Raised if arg is an Attr that is already an attribute of another Element object.
 *  The DOM user must explicitly clone Attr nodes to re-use them in other elements.
 *
 * <span class="attrib">@return</span> : DOMNode - If the new Node replaces an existing node with the same name the previously existing Node is returned,
 *   otherwise null is returned
 */</span>
DOMNamedNodeMap.<span class="reserved">prototype</span>.setNamedItem = <span class="reserved">function</span> DOMNamedNodeMap_setNamedItem(arg) {
  <span class="comment">// test for exceptions</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking) {
    <span class="comment">// throw Exception if arg was not created by this Document</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument != arg.ownerDocument) {
      throw(new DOMException(DOMException.WRONG_DOCUMENT_ERR));
    }

    <span class="comment">// throw Exception if DOMNamedNodeMap is readonly</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>._readonly || (<span class="reserved">this</span>.parentNode &amp;&amp; <span class="reserved">this</span>.parentNode._readonly)) {
      throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
    }

    <span class="comment">// throw Exception if arg is already an attribute of another Element object</span>
    <span class="reserved">if</span> (arg.ownerElement &amp;&amp; (arg.ownerElement != <span class="reserved">this</span>.parentNode)) {
      throw(new DOMException(DOMException.INUSE_ATTRIBUTE_ERR));
    }
  }

  <span class="comment">// get item index</span>
  var itemIndex = <span class="reserved">this</span>._findNamedItemIndex(arg.name);
  var ret = null;

  <span class="reserved">if</span> (itemIndex &gt; -1) {                          <span class="comment">// found it!</span>
    ret = <span class="reserved">this</span>._nodes[itemIndex];                <span class="comment">// use existing Attribute</span>

    <span class="comment">// throw Exception if DOMAttr is readonly</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; ret._readonly) {
      throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
    }
    <span class="reserved">else</span> {
      <span class="reserved">this</span>._nodes[itemIndex] = arg;                <span class="comment">// over-write existing NamedNode</span>
    }
  }
  <span class="reserved">else</span> {
    <span class="reserved">this</span>._nodes[<span class="reserved">this</span>.length] = arg;              <span class="comment">// add new NamedNode</span>
  }

  <span class="reserved">this</span>.length = <span class="reserved">this</span>._nodes.length;              <span class="comment">// update length</span>

  arg.ownerElement = <span class="reserved">this</span>.parentNode;            <span class="comment">// update ownerElement</span>

  <span class="reserved">return</span> ret;                                    <span class="comment">// return old node or null</span>
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamedNodeMap.removeNamedItem - Removes a node specified by name.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  name : string - The name of a node to remove
 *
 * <span class="attrib">@throws</span> : DOMException - NOT_FOUND_ERR: Raised if there is no node named name in this map.
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this NamedNodeMap is readonly.
 *
 * <span class="attrib">@return</span> : DOMNode - The node removed from the map or null if no node with such a name exists.
 */</span>
DOMNamedNodeMap.<span class="reserved">prototype</span>.removeNamedItem = <span class="reserved">function</span> DOMNamedNodeMap_removeNamedItem(name) {
  var ret = null;
  <span class="comment">// test for exceptions</span>
  <span class="comment">// throw Exception if DOMNamedNodeMap is readonly</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; (<span class="reserved">this</span>._readonly || (<span class="reserved">this</span>.parentNode &amp;&amp; <span class="reserved">this</span>.parentNode._readonly))) {
    throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
  }

  <span class="comment">// get item index</span>
  var itemIndex = <span class="reserved">this</span>._findNamedItemIndex(name);

  <span class="comment">// throw Exception if there is no node named name in this map</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; (itemIndex &lt; 0)) {
    throw(new DOMException(DOMException.NOT_FOUND_ERR));
  }

  <span class="comment">// get Node</span>
  var oldNode = <span class="reserved">this</span>._nodes[itemIndex];

  <span class="comment">// throw Exception if Node is readonly</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; oldNode._readonly) {
    throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
  }

  <span class="comment">// return removed node</span>
  <span class="reserved">return</span> <span class="reserved">this</span>._removeChild(itemIndex);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamedNodeMap.getNamedItemNS - Retrieves a node specified by name
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  namespaceURI : string - the namespace URI of the required node
 * <span class="attrib">@param</span>  localName    : string - the local name of the required node
 *
 * <span class="attrib">@return</span> : DOMNode
 */</span>
DOMNamedNodeMap.<span class="reserved">prototype</span>.getNamedItemNS = <span class="reserved">function</span> DOMNamedNodeMap_getNamedItemNS(namespaceURI, localName) {
  var ret = null;

  <span class="comment">// test that Named Node exists</span>
  var itemIndex = <span class="reserved">this</span>._findNamedItemNSIndex(namespaceURI, localName);

  <span class="reserved">if</span> (itemIndex &gt; -1) {                          <span class="comment">// found it!</span>
    ret = <span class="reserved">this</span>._nodes[itemIndex];                <span class="comment">// return NamedNode</span>
  }

  <span class="reserved">return</span> ret;                                    <span class="comment">// if node is not found, default value null is returned</span>
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamedNodeMap.setNamedItemNS - Adds a node using
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  arg : string - A node to store in a named node map.
 *   The node will later be accessible using the value of the nodeName attribute of the node.
 *   If a node with that name is already present in the map, it is replaced by the new one.
 *
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this NamedNodeMap is readonly.
 * <span class="attrib">@throws</span> : DOMException - WRONG_DOCUMENT_ERR: Raised if arg was created from a different document than the one that created this map.
 * <span class="attrib">@throws</span> : DOMException - INUSE_ATTRIBUTE_ERR: Raised if arg is an Attr that is already an attribute of another Element object.
 *   The DOM user must explicitly clone Attr nodes to re-use them in other elements.
 *
 * <span class="attrib">@return</span> : DOMNode - If the new Node replaces an existing node with the same name the previously existing Node is returned,
 *   otherwise null is returned
 */</span>
DOMNamedNodeMap.<span class="reserved">prototype</span>.setNamedItemNS = <span class="reserved">function</span> DOMNamedNodeMap_setNamedItemNS(arg) {
  <span class="comment">// test for exceptions</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking) {
    <span class="comment">// throw Exception if DOMNamedNodeMap is readonly</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>._readonly || (<span class="reserved">this</span>.parentNode &amp;&amp; <span class="reserved">this</span>.parentNode._readonly)) {
      throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
    }

    <span class="comment">// throw Exception if arg was not created by this Document</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument != arg.ownerDocument) {
      throw(new DOMException(DOMException.WRONG_DOCUMENT_ERR));
    }

    <span class="comment">// throw Exception if arg is already an attribute of another Element object</span>
    <span class="reserved">if</span> (arg.ownerElement &amp;&amp; (arg.ownerElement != <span class="reserved">this</span>.parentNode)) {
      throw(new DOMException(DOMException.INUSE_ATTRIBUTE_ERR));
    }
  }

  <span class="comment">// get item index</span>
  var itemIndex = <span class="reserved">this</span>._findNamedItemNSIndex(arg.namespaceURI, arg.localName);
  var ret = null;

  <span class="reserved">if</span> (itemIndex &gt; -1) {                          <span class="comment">// found it!</span>
    ret = <span class="reserved">this</span>._nodes[itemIndex];                <span class="comment">// use existing Attribute</span>
    <span class="comment">// throw Exception if DOMAttr is readonly</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; ret._readonly) {
      throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
    }
    <span class="reserved">else</span> {
      <span class="reserved">this</span>._nodes[itemIndex] = arg;                <span class="comment">// over-write existing NamedNode</span>
    }
  }
  <span class="reserved">else</span> {
    <span class="reserved">this</span>._nodes[<span class="reserved">this</span>.length] = arg;              <span class="comment">// add new NamedNode</span>
  }

  <span class="reserved">this</span>.length = <span class="reserved">this</span>._nodes.length;              <span class="comment">// update length</span>

  arg.ownerElement = <span class="reserved">this</span>.parentNode;


  <span class="reserved">return</span> ret;                                    <span class="comment">// return old node or null</span>
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamedNodeMap.removeNamedItemNS - Removes a node specified by name.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  namespaceURI : string - the namespace URI of the required node
 * <span class="attrib">@param</span>  localName    : string - the local name of the required node
 *
 * <span class="attrib">@throws</span> : DOMException - NOT_FOUND_ERR: Raised if there is no node with the specified namespaceURI and localName in this map.
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this NamedNodeMap is readonly.
 *
 * <span class="attrib">@return</span> : DOMNode - The node removed from the map or null if no node with such a name exists.
 */</span>
DOMNamedNodeMap.<span class="reserved">prototype</span>.removeNamedItemNS = <span class="reserved">function</span> DOMNamedNodeMap_removeNamedItemNS(namespaceURI, localName) {
  var ret = null;

  <span class="comment">// test for exceptions</span>
  <span class="comment">// throw Exception if DOMNamedNodeMap is readonly</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; (<span class="reserved">this</span>._readonly || (<span class="reserved">this</span>.parentNode &amp;&amp; <span class="reserved">this</span>.parentNode._readonly))) {
    throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
  }

  <span class="comment">// get item index</span>
  var itemIndex = <span class="reserved">this</span>._findNamedItemNSIndex(namespaceURI, localName);

  <span class="comment">// throw Exception if there is no matching node in this map</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; (itemIndex &lt; 0)) {
    throw(new DOMException(DOMException.NOT_FOUND_ERR));
  }

  <span class="comment">// get Node</span>
  var oldNode = <span class="reserved">this</span>._nodes[itemIndex];

  <span class="comment">// throw Exception if Node is readonly</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; oldNode._readonly) {
    throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
  }

  <span class="reserved">return</span> <span class="reserved">this</span>._removeChild(itemIndex);             <span class="comment">// return removed node</span>
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamedNodeMap._findNamedItemIndex - find the item index of the node with the specified name
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  name : string - the name of the required node
 *
 * <span class="attrib">@return</span> : int
 */</span>
DOMNamedNodeMap.<span class="reserved">prototype</span>._findNamedItemIndex = <span class="reserved">function</span> DOMNamedNodeMap__findNamedItemIndex(name) {
  var ret = -1;

  <span class="comment">// loop through all nodes</span>
  <span class="reserved">for</span> (var i=0; i&lt;<span class="reserved">this</span>._nodes.length; i++) {
    <span class="comment">// compare name to each node's nodeName</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>._nodes[i].name == name) {         <span class="comment">// found it!</span>
      ret = i;
      break;
    }
  }

  <span class="reserved">return</span> ret;                                    <span class="comment">// if node is not found, default value -1 is returned</span>
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamedNodeMap._findNamedItemNSIndex - find the item index of the node with the specified namespaceURI and localName
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  namespaceURI : string - the namespace URI of the required node
 * <span class="attrib">@param</span>  localName    : string - the local name of the required node
 *
 * <span class="attrib">@return</span> : int
 */</span>
DOMNamedNodeMap.<span class="reserved">prototype</span>._findNamedItemNSIndex = <span class="reserved">function</span> DOMNamedNodeMap__findNamedItemNSIndex(namespaceURI, localName) {
  var ret = -1;

  <span class="comment">// test that localName is not null</span>
  <span class="reserved">if</span> (localName) {
    <span class="comment">// loop through all nodes</span>
    <span class="reserved">for</span> (var i=0; i&lt;<span class="reserved">this</span>._nodes.length; i++) {
      <span class="comment">// compare name to each node's namespaceURI and localName</span>
      <span class="reserved">if</span> ((<span class="reserved">this</span>._nodes[i].namespaceURI == namespaceURI) &amp;&amp; (<span class="reserved">this</span>._nodes[i].localName == localName)) {
        ret = i;                                 <span class="comment">// found it!</span>
        break;
      }
    }
  }

  <span class="reserved">return</span> ret;                                    <span class="comment">// if node is not found, default value -1 is returned</span>
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamedNodeMap._hasAttribute - Returns true if specified node exists
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  name : string - the name of the required node
 *
 * <span class="attrib">@return</span> : boolean
 */</span>
DOMNamedNodeMap.<span class="reserved">prototype</span>._hasAttribute = <span class="reserved">function</span> DOMNamedNodeMap__hasAttribute(name) {
  var ret = false;

  <span class="comment">// test that Named Node exists</span>
  var itemIndex = <span class="reserved">this</span>._findNamedItemIndex(name);

  <span class="reserved">if</span> (itemIndex &gt; -1) {                          <span class="comment">// found it!</span>
    ret = true;                                  <span class="comment">// return true</span>
  }

  <span class="reserved">return</span> ret;                                    <span class="comment">// if node is not found, default value false is returned</span>
}

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamedNodeMap._hasAttributeNS - Returns true if specified node exists
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  namespaceURI : string - the namespace URI of the required node
 * <span class="attrib">@param</span>  localName    : string - the local name of the required node
 *
 * <span class="attrib">@return</span> : boolean
 */</span>
DOMNamedNodeMap.<span class="reserved">prototype</span>._hasAttributeNS = <span class="reserved">function</span> DOMNamedNodeMap__hasAttributeNS(namespaceURI, localName) {
  var ret = false;

  <span class="comment">// test that Named Node exists</span>
  var itemIndex = <span class="reserved">this</span>._findNamedItemNSIndex(namespaceURI, localName);

  <span class="reserved">if</span> (itemIndex &gt; -1) {                          <span class="comment">// found it!</span>
    ret = true;                                  <span class="comment">// return true</span>
  }

  <span class="reserved">return</span> ret;                                    <span class="comment">// if node is not found, default value false is returned</span>
}

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamedNodeMap._cloneNodes - Returns a NamedNodeMap containing clones of the Nodes in this NamedNodeMap
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  parentNode : DOMNode - the new parent of the cloned NodeList
 *
 * <span class="attrib">@return</span> : DOMNamedNodeMap - NamedNodeMap containing clones of the Nodes in this DOMNamedNodeMap
 */</span>
DOMNamedNodeMap.<span class="reserved">prototype</span>._cloneNodes = <span class="reserved">function</span> DOMNamedNodeMap__cloneNodes(parentNode) {
  var cloneNamedNodeMap = new DOMNamedNodeMap(<span class="reserved">this</span>.ownerDocument, parentNode);

  <span class="comment">// create list containing clones of all children</span>
  <span class="reserved">for</span> (var i=0; i &lt; <span class="reserved">this</span>._nodes.length; i++) {
    cloneNamedNodeMap._appendChild(<span class="reserved">this</span>._nodes[i].cloneNode(false));
  }

  <span class="reserved">return</span> cloneNamedNodeMap;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamedNodeMap.toString - Serialize this NodeMap into an XML string
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au) and David Joham (djoham<span class="attrib">@yahoo</span>.com)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMNamedNodeMap.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span> DOMNamedNodeMap_toString() {
  var ret = <span class="literal">""</span>;

  <span class="comment">// create string containing concatenation of all (but last) Attribute string values (separated by spaces)</span>
  <span class="reserved">for</span> (var i=0; i &lt; <span class="reserved">this</span>.length -1; i++) {
    ret += <span class="reserved">this</span>._nodes[i].toString() +<span class="literal">" "</span>;
  }

  <span class="comment">// add last Attribute to string (without trailing space)</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.length &gt; 0) {
    ret += <span class="reserved">this</span>._nodes[<span class="reserved">this</span>.length -1].toString();
  }

  <span class="reserved">return</span> ret;
};

<span class="comment">/**
 * <span class="attrib">@class</span>  DOMNamespaceNodeMap - used to represent collections of namespace nodes that can be accessed by name
 *  typically a set of Element attributes
 *
 * <span class="attrib">@extends</span> DOMNamedNodeMap
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  ownerDocument : DOMDocument - the ownerDocument
 * <span class="attrib">@param</span>  parentNode    : DOMNode - the node that the DOMNamespaceNodeMap is attached to (or null)
 */</span>
DOMNamespaceNodeMap = <span class="reserved">function</span>(ownerDocument, parentNode) {
  <span class="reserved">this</span>._class = addClass(<span class="reserved">this</span>._class, <span class="literal">"DOMNamespaceNodeMap"</span>);
  <span class="reserved">this</span>.DOMNamedNodeMap = DOMNamedNodeMap;
  <span class="reserved">this</span>.DOMNamedNodeMap(ownerDocument, parentNode);
};
DOMNamespaceNodeMap.<span class="reserved">prototype</span> = new DOMNamedNodeMap;

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamespaceNodeMap._findNamedItemIndex - find the item index of the node with the specified localName
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  localName : string - the localName of the required node
 *
 * <span class="attrib">@return</span> : int
 */</span>
DOMNamespaceNodeMap.<span class="reserved">prototype</span>._findNamedItemIndex = <span class="reserved">function</span> DOMNamespaceNodeMap__findNamedItemIndex(localName) {
  var ret = -1;

  <span class="comment">// loop through all nodes</span>
  <span class="reserved">for</span> (var i=0; i&lt;<span class="reserved">this</span>._nodes.length; i++) {
    <span class="comment">// compare name to each node's nodeName</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>._nodes[i].localName == localName) {         <span class="comment">// found it!</span>
      ret = i;
      break;
    }
  }

  <span class="reserved">return</span> ret;                                    <span class="comment">// if node is not found, default value -1 is returned</span>
};


<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamespaceNodeMap._cloneNodes - Returns a NamespaceNodeMap containing clones of the Nodes in this NamespaceNodeMap
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  parentNode : DOMNode - the new parent of the cloned NodeList
 *
 * <span class="attrib">@return</span> : DOMNamespaceNodeMap - NamespaceNodeMap containing clones of the Nodes in this NamespaceNodeMap
 */</span>
DOMNamespaceNodeMap.<span class="reserved">prototype</span>._cloneNodes = <span class="reserved">function</span> DOMNamespaceNodeMap__cloneNodes(parentNode) {
  var cloneNamespaceNodeMap = new DOMNamespaceNodeMap(<span class="reserved">this</span>.ownerDocument, parentNode);

  <span class="comment">// create list containing clones of all children</span>
  <span class="reserved">for</span> (var i=0; i &lt; <span class="reserved">this</span>._nodes.length; i++) {
    cloneNamespaceNodeMap._appendChild(<span class="reserved">this</span>._nodes[i].cloneNode(false));
  }

  <span class="reserved">return</span> cloneNamespaceNodeMap;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamespaceNodeMap.toString - Serialize this NamespaceNodeMap into an XML string
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au) and David Joham (djoham<span class="attrib">@yahoo</span>.com)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMNamespaceNodeMap.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span> DOMNamespaceNodeMap_toString() {
  var ret = <span class="literal">""</span>;

  <span class="comment">// identify namespaces declared local to this Element (ie, not inherited)</span>
  <span class="reserved">for</span> (var ind = 0; ind &lt; <span class="reserved">this</span>._nodes.length; ind++) {
    <span class="comment">// if namespace declaration does not exist in the containing node's, parentNode's namespaces</span>
    var ns = null;
    try {
        var ns = <span class="reserved">this</span>.parentNode.parentNode._namespaces.getNamedItem(<span class="reserved">this</span>._nodes[ind].localName);
    }
    catch (e) {
        <span class="comment">//breaking to prevent default namespace being inserted into return value</span>
        break;
    }
    <span class="reserved">if</span> (!(ns &amp;&amp; (<span class="literal">""</span>+ ns.nodeValue == <span class="literal">""</span>+ <span class="reserved">this</span>._nodes[ind].nodeValue))) {
      <span class="comment">// display the namespace declaration</span>
      ret += <span class="reserved">this</span>._nodes[ind].toString() +<span class="literal">" "</span>;
    }
  }

  <span class="reserved">return</span> ret;
};

<span class="comment">/**
 * <span class="attrib">@class</span>  DOMNode - The Node interface is the primary datatype for the entire Document Object Model.
 *   It represents a single node in the document tree.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  ownerDocument : DOMDocument - The Document object associated with this node.
 */</span>
DOMNode = <span class="reserved">function</span>(ownerDocument) {
  <span class="reserved">this</span>._class = addClass(<span class="reserved">this</span>._class, <span class="literal">"DOMNode"</span>);

  <span class="reserved">if</span> (ownerDocument) {
    <span class="reserved">this</span>._id = ownerDocument._genId();           <span class="comment">// generate unique internal id</span>
  }

  <span class="reserved">this</span>.namespaceURI = <span class="literal">""</span>;                        <span class="comment">// The namespace URI of this node (Level 2)</span>
  <span class="reserved">this</span>.prefix       = <span class="literal">""</span>;                        <span class="comment">// The namespace prefix of this node (Level 2)</span>
  <span class="reserved">this</span>.localName    = <span class="literal">""</span>;                        <span class="comment">// The localName of this node (Level 2)</span>

  <span class="reserved">this</span>.nodeName = <span class="literal">""</span>;                            <span class="comment">// The name of this node</span>
  <span class="reserved">this</span>.nodeValue = <span class="literal">""</span>;                           <span class="comment">// The value of this node</span>
  <span class="reserved">this</span>.nodeType = 0;                             <span class="comment">// A code representing the type of the underlying object</span>

  <span class="comment">// The parent of this node. All nodes, except Document, DocumentFragment, and Attr may have a parent.</span>
  <span class="comment">// However, if a node has just been created and not yet added to the tree, or if it has been removed from the tree, this is null</span>
  <span class="reserved">this</span>.parentNode      = null;

  <span class="comment">// A NodeList that contains all children of this node. If there are no children, this is a NodeList containing no nodes.</span>
  <span class="comment">// The content of the returned NodeList is "live" in the sense that, for instance, changes to the children of the node object</span>
  <span class="comment">// that it was created from are immediately reflected in the nodes returned by the NodeList accessors;</span>
  <span class="comment">// it is not a static snapshot of the content of the node. This is true for every NodeList, including the ones returned by the getElementsByTagName method.</span>
  <span class="reserved">this</span>.childNodes      = new DOMNodeList(ownerDocument, <span class="reserved">this</span>);

  <span class="reserved">this</span>.firstChild      = null;                   <span class="comment">// The first child of this node. If there is no such node, this is null</span>
  <span class="reserved">this</span>.lastChild       = null;                   <span class="comment">// The last child of this node. If there is no such node, this is null.</span>
  <span class="reserved">this</span>.previousSibling = null;                   <span class="comment">// The node immediately preceding this node. If there is no such node, this is null.</span>
  <span class="reserved">this</span>.nextSibling     = null;                   <span class="comment">// The node immediately following this node. If there is no such node, this is null.</span>

  <span class="reserved">this</span>.attributes = new DOMNamedNodeMap(ownerDocument, <span class="reserved">this</span>);   <span class="comment">// A NamedNodeMap containing the attributes of this node (if it is an Element) or null otherwise.</span>
  <span class="reserved">this</span>.ownerDocument   = ownerDocument;          <span class="comment">// The Document object associated with this node</span>
  <span class="reserved">this</span>._namespaces = new DOMNamespaceNodeMap(ownerDocument, <span class="reserved">this</span>);  <span class="comment">// The namespaces in scope for this node</span>

  <span class="reserved">this</span>._readonly = false;
};

<span class="comment">// nodeType constants</span>
DOMNode.ELEMENT_NODE                = 1;
DOMNode.ATTRIBUTE_NODE              = 2;
DOMNode.TEXT_NODE                   = 3;
DOMNode.CDATA_SECTION_NODE          = 4;
DOMNode.ENTITY_REFERENCE_NODE       = 5;
DOMNode.ENTITY_NODE                 = 6;
DOMNode.PROCESSING_INSTRUCTION_NODE = 7;
DOMNode.COMMENT_NODE                = 8;
DOMNode.DOCUMENT_NODE               = 9;
DOMNode.DOCUMENT_TYPE_NODE          = 10;
DOMNode.DOCUMENT_FRAGMENT_NODE      = 11;
DOMNode.NOTATION_NODE               = 12;
DOMNode.NAMESPACE_NODE              = 13;

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.hasAttributes
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au) &amp; David Joham (djoham<span class="attrib">@yahoo</span>.com)
 *
 * <span class="attrib">@return</span> : boolean
 */</span>
DOMNode.<span class="reserved">prototype</span>.hasAttributes = <span class="reserved">function</span> DOMNode_hasAttributes() {
    <span class="reserved">if</span> (<span class="reserved">this</span>.attributes.length == 0) {
        <span class="reserved">return</span> false;
    }
    <span class="reserved">else</span> {
        <span class="reserved">return</span> true;
    }
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.getNodeName - Java style gettor for .nodeName
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMNode.<span class="reserved">prototype</span>.getNodeName = <span class="reserved">function</span> DOMNode_getNodeName() {
  <span class="reserved">return</span> <span class="reserved">this</span>.nodeName;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.getNodeValue - Java style gettor for .NodeValue
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMNode.<span class="reserved">prototype</span>.getNodeValue = <span class="reserved">function</span> DOMNode_getNodeValue() {
  <span class="reserved">return</span> <span class="reserved">this</span>.nodeValue;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.setNodeValue - Java style settor for .NodeValue
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  nodeValue : string - unique internal id
 */</span>
DOMNode.<span class="reserved">prototype</span>.setNodeValue = <span class="reserved">function</span> DOMNode_setNodeValue(nodeValue) {
  <span class="comment">// throw Exception if DOMNode is readonly</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; <span class="reserved">this</span>._readonly) {
    throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
  }

  <span class="reserved">this</span>.nodeValue = nodeValue;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.getNodeType - Java style gettor for .nodeType
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : int
 */</span>
DOMNode.<span class="reserved">prototype</span>.getNodeType = <span class="reserved">function</span> DOMNode_getNodeType() {
  <span class="reserved">return</span> <span class="reserved">this</span>.nodeType;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.getParentNode - Java style gettor for .parentNode
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : DOMNode
 */</span>
DOMNode.<span class="reserved">prototype</span>.getParentNode = <span class="reserved">function</span> DOMNode_getParentNode() {
  <span class="reserved">return</span> <span class="reserved">this</span>.parentNode;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.getChildNodes - Java style gettor for .childNodes
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : DOMNodeList
 */</span>
DOMNode.<span class="reserved">prototype</span>.getChildNodes = <span class="reserved">function</span> DOMNode_getChildNodes() {
  <span class="reserved">return</span> <span class="reserved">this</span>.childNodes;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.getFirstChild - Java style gettor for .firstChild
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : DOMNode
 */</span>
DOMNode.<span class="reserved">prototype</span>.getFirstChild = <span class="reserved">function</span> DOMNode_getFirstChild() {
  <span class="reserved">return</span> <span class="reserved">this</span>.firstChild;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.getLastChild - Java style gettor for .lastChild
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : DOMNode
 */</span>
DOMNode.<span class="reserved">prototype</span>.getLastChild = <span class="reserved">function</span> DOMNode_getLastChild() {
  <span class="reserved">return</span> <span class="reserved">this</span>.lastChild;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.getPreviousSibling - Java style gettor for .previousSibling
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : DOMNode
 */</span>
DOMNode.<span class="reserved">prototype</span>.getPreviousSibling = <span class="reserved">function</span> DOMNode_getPreviousSibling() {
  <span class="reserved">return</span> <span class="reserved">this</span>.previousSibling;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.getNextSibling - Java style gettor for .nextSibling
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : DOMNode
 */</span>
DOMNode.<span class="reserved">prototype</span>.getNextSibling = <span class="reserved">function</span> DOMNode_getNextSibling() {
  <span class="reserved">return</span> <span class="reserved">this</span>.nextSibling;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.getAttributes - Java style gettor for .attributes
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : DOMNamedNodeList
 */</span>
DOMNode.<span class="reserved">prototype</span>.getAttributes = <span class="reserved">function</span> DOMNode_getAttributes() {
  <span class="reserved">return</span> <span class="reserved">this</span>.attributes;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.getOwnerDocument - Java style gettor for .ownerDocument
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : DOMDocument
 */</span>
DOMNode.<span class="reserved">prototype</span>.getOwnerDocument = <span class="reserved">function</span> DOMNode_getOwnerDocument() {
  <span class="reserved">return</span> <span class="reserved">this</span>.ownerDocument;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.getNamespaceURI - Java style gettor for .namespaceURI
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : String
 */</span>
DOMNode.<span class="reserved">prototype</span>.getNamespaceURI = <span class="reserved">function</span> DOMNode_getNamespaceURI() {
  <span class="reserved">return</span> <span class="reserved">this</span>.namespaceURI;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.getPrefix - Java style gettor for .prefix
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : String
 */</span>
DOMNode.<span class="reserved">prototype</span>.getPrefix = <span class="reserved">function</span> DOMNode_getPrefix() {
  <span class="reserved">return</span> <span class="reserved">this</span>.prefix;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.setPrefix - Java style settor for .prefix
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>   prefix : String
 *
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this Node is readonly.
 * <span class="attrib">@throws</span> : DOMException - INVALID_CHARACTER_ERR: Raised if the string contains an illegal character
 * <span class="attrib">@throws</span> : DOMException - NAMESPACE_ERR: Raised if the Namespace is invalid
 *
 */</span>
DOMNode.<span class="reserved">prototype</span>.setPrefix = <span class="reserved">function</span> DOMNode_setPrefix(prefix) {
  <span class="comment">// test for exceptions</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking) {
    <span class="comment">// throw Exception if DOMNode is readonly</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>._readonly) {
      throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
    }

    <span class="comment">// throw Exception if the prefix string contains an illegal character</span>
    <span class="reserved">if</span> (!<span class="reserved">this</span>.ownerDocument.implementation._isValidName(prefix)) {
      throw(new DOMException(DOMException.INVALID_CHARACTER_ERR));
    }

    <span class="comment">// throw Exception if the Namespace is invalid;</span>
    <span class="comment">//  if the specified prefix is malformed,</span>
    <span class="comment">//  if the namespaceURI of this node is null,</span>
    <span class="comment">//  if the specified prefix is "xml" and the namespaceURI of this node is</span>
    <span class="comment">//   different from "http://www.w3.org/XML/1998/namespace",</span>
    <span class="reserved">if</span> (!<span class="reserved">this</span>.ownerDocument._isValidNamespace(<span class="reserved">this</span>.namespaceURI, prefix +<span class="literal">":"</span>+ <span class="reserved">this</span>.localName)) {
      throw(new DOMException(DOMException.NAMESPACE_ERR));
    }

    <span class="comment">// throw Exception if we are trying to make the attribute look like a namespace declaration;</span>
    <span class="comment">//  if this node is an attribute and the specified prefix is "xmlns"</span>
    <span class="comment">//   and the namespaceURI of this node is different from "http://www.w3.org/2000/xmlns/",</span>
    <span class="reserved">if</span> ((prefix == <span class="literal">"xmlns"</span>) &amp;&amp; (<span class="reserved">this</span>.namespaceURI != <span class="literal">"http://www.w3.org/2000/xmlns/"</span>)) {
      throw(new DOMException(DOMException.NAMESPACE_ERR));
    }

    <span class="comment">// throw Exception if we are trying to make the attribute look like a default namespace declaration;</span>
    <span class="comment">//  if this node is an attribute and the qualifiedName of this node is "xmlns" [Namespaces].</span>
    <span class="reserved">if</span> ((prefix == <span class="literal">""</span>) &amp;&amp; (<span class="reserved">this</span>.localName == <span class="literal">"xmlns"</span>)) {
      throw(new DOMException(DOMException.NAMESPACE_ERR));
    }
  }

  <span class="comment">// update prefix</span>
  <span class="reserved">this</span>.prefix = prefix;

  <span class="comment">// update nodeName (QName)</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.prefix != <span class="literal">""</span>) {
    <span class="reserved">this</span>.nodeName = <span class="reserved">this</span>.prefix +<span class="literal">":"</span>+ <span class="reserved">this</span>.localName;
  }
  <span class="reserved">else</span> {
    <span class="reserved">this</span>.nodeName = <span class="reserved">this</span>.localName;  <span class="comment">// no prefix, therefore nodeName is simply localName</span>
  }
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.getLocalName - Java style gettor for .localName
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : String
 */</span>
DOMNode.<span class="reserved">prototype</span>.getLocalName = <span class="reserved">function</span> DOMNode_getLocalName() {
  <span class="reserved">return</span> <span class="reserved">this</span>.localName;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.insertBefore - Inserts the node newChild before the existing child node refChild.
 *   If refChild is null, insert newChild at the end of the list of children.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  newChild : DOMNode - The node to insert.
 * <span class="attrib">@param</span>  refChild : DOMNode - The reference node, i.e., the node before which the new node must be inserted
 *
 * <span class="attrib">@throws</span> : DOMException - HIERARCHY_REQUEST_ERR: Raised if the node to insert is one of this node's ancestors
 * <span class="attrib">@throws</span> : DOMException - WRONG_DOCUMENT_ERR: Raised if arg was created from a different document than the one that created this map.
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this Node is readonly.
 * <span class="attrib">@throws</span> : DOMException - NOT_FOUND_ERR: Raised if there is no node named name in this map.
 *
 * <span class="attrib">@return</span> : DOMNode - The node being inserted.
 */</span>
DOMNode.<span class="reserved">prototype</span>.insertBefore = <span class="reserved">function</span> DOMNode_insertBefore(newChild, refChild) {
  var prevNode;

  <span class="comment">// test for exceptions</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking) {
    <span class="comment">// throw Exception if DOMNode is readonly</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>._readonly) {
      throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
    }

    <span class="comment">// throw Exception if newChild was not created by this Document</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument != newChild.ownerDocument) {
      throw(new DOMException(DOMException.WRONG_DOCUMENT_ERR));
    }

    <span class="comment">// throw Exception if the node is an ancestor</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>._isAncestor(newChild)) {
      throw(new DOMException(DOMException.HIERARCHY_REQUEST_ERR));
    }
  }

  <span class="reserved">if</span> (refChild) {                                <span class="comment">// if refChild is specified, insert before it</span>
    <span class="comment">// find index of refChild</span>
    var itemIndex = <span class="reserved">this</span>.childNodes._findItemIndex(refChild._id);

    <span class="comment">// throw Exception if there is no child node with this id</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; (itemIndex &lt; 0)) {
      throw(new DOMException(DOMException.NOT_FOUND_ERR));
    }

    <span class="comment">// if the newChild is already in the tree,</span>
    var newChildParent = newChild.parentNode;
    <span class="reserved">if</span> (newChildParent) {
      <span class="comment">// remove it</span>
      newChildParent.removeChild(newChild);
    }

    <span class="comment">// insert newChild into childNodes</span>
    <span class="reserved">this</span>.childNodes._insertBefore(newChild, <span class="reserved">this</span>.childNodes._findItemIndex(refChild._id));

    <span class="comment">// do node pointer surgery</span>
    prevNode = refChild.previousSibling;

    <span class="comment">// handle DocumentFragment</span>
    <span class="reserved">if</span> (newChild.nodeType == DOMNode.DOCUMENT_FRAGMENT_NODE) {
      <span class="reserved">if</span> (newChild.childNodes._nodes.length &gt; 0) {
        <span class="comment">// set the parentNode of DocumentFragment's children</span>
        <span class="reserved">for</span> (var ind = 0; ind &lt; newChild.childNodes._nodes.length; ind++) {
          newChild.childNodes._nodes[ind].parentNode = <span class="reserved">this</span>;
        }

        <span class="comment">// link refChild to last child of DocumentFragment</span>
        refChild.previousSibling = newChild.childNodes._nodes[newChild.childNodes._nodes.length-1];
      }
    }
    <span class="reserved">else</span> {
      newChild.parentNode = <span class="reserved">this</span>;                <span class="comment">// set the parentNode of the newChild</span>
      refChild.previousSibling = newChild;       <span class="comment">// link refChild to newChild</span>
    }
  }
  <span class="reserved">else</span> {                                         <span class="comment">// otherwise, append to end</span>
    prevNode = <span class="reserved">this</span>.lastChild;
    <span class="reserved">this</span>.appendChild(newChild);
  }

  <span class="reserved">if</span> (newChild.nodeType == DOMNode.DOCUMENT_FRAGMENT_NODE) {
    <span class="comment">// do node pointer surgery for DocumentFragment</span>
    <span class="reserved">if</span> (newChild.childNodes._nodes.length &gt; 0) {
      <span class="reserved">if</span> (prevNode) {
        prevNode.nextSibling = newChild.childNodes._nodes[0];
      }
      <span class="reserved">else</span> {                                         <span class="comment">// this is the first child in the list</span>
        <span class="reserved">this</span>.firstChild = newChild.childNodes._nodes[0];
      }

      newChild.childNodes._nodes[0].previousSibling = prevNode;
      newChild.childNodes._nodes[newChild.childNodes._nodes.length-1].nextSibling = refChild;
    }
  }
  <span class="reserved">else</span> {
    <span class="comment">// do node pointer surgery for newChild</span>
    <span class="reserved">if</span> (prevNode) {
      prevNode.nextSibling = newChild;
    }
    <span class="reserved">else</span> {                                         <span class="comment">// this is the first child in the list</span>
      <span class="reserved">this</span>.firstChild = newChild;
    }

    newChild.previousSibling = prevNode;
    newChild.nextSibling     = refChild;
  }

  <span class="reserved">return</span> newChild;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.replaceChild - Replaces the child node oldChild with newChild in the list of children,
 *   and returns the oldChild node.
 *   If the newChild is already in the tree, it is first removed.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  newChild : DOMNode - The node to insert.
 * <span class="attrib">@param</span>  oldChild : DOMNode - The node being replaced in the list.
 *
 * <span class="attrib">@throws</span> : DOMException - HIERARCHY_REQUEST_ERR: Raised if the node to insert is one of this node's ancestors
 * <span class="attrib">@throws</span> : DOMException - WRONG_DOCUMENT_ERR: Raised if arg was created from a different document than the one that created this map.
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this Node is readonly.
 * <span class="attrib">@throws</span> : DOMException - NOT_FOUND_ERR: Raised if there is no node named name in this map.
 *
 * <span class="attrib">@return</span> : DOMNode - The node that was replaced
 */</span>
DOMNode.<span class="reserved">prototype</span>.replaceChild = <span class="reserved">function</span> DOMNode_replaceChild(newChild, oldChild) {
  var ret = null;

  <span class="comment">// test for exceptions</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking) {
    <span class="comment">// throw Exception if DOMNode is readonly</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>._readonly) {
      throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
    }

    <span class="comment">// throw Exception if newChild was not created by this Document</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument != newChild.ownerDocument) {
      throw(new DOMException(DOMException.WRONG_DOCUMENT_ERR));
    }

    <span class="comment">// throw Exception if the node is an ancestor</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>._isAncestor(newChild)) {
      throw(new DOMException(DOMException.HIERARCHY_REQUEST_ERR));
    }
  }

  <span class="comment">// get index of oldChild</span>
  var index = <span class="reserved">this</span>.childNodes._findItemIndex(oldChild._id);

  <span class="comment">// throw Exception if there is no child node with this id</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; (index &lt; 0)) {
    throw(new DOMException(DOMException.NOT_FOUND_ERR));
  }

  <span class="comment">// if the newChild is already in the tree,</span>
  var newChildParent = newChild.parentNode;
  <span class="reserved">if</span> (newChildParent) {
    <span class="comment">// remove it</span>
    newChildParent.removeChild(newChild);
  }

  <span class="comment">// add newChild to childNodes</span>
  ret = <span class="reserved">this</span>.childNodes._replaceChild(newChild, index);


  <span class="reserved">if</span> (newChild.nodeType == DOMNode.DOCUMENT_FRAGMENT_NODE) {
    <span class="comment">// do node pointer surgery for Document Fragment</span>
    <span class="reserved">if</span> (newChild.childNodes._nodes.length &gt; 0) {
      <span class="reserved">for</span> (var ind = 0; ind &lt; newChild.childNodes._nodes.length; ind++) {
        newChild.childNodes._nodes[ind].parentNode = <span class="reserved">this</span>;
      }

      <span class="reserved">if</span> (oldChild.previousSibling) {
        oldChild.previousSibling.nextSibling = newChild.childNodes._nodes[0];
      }
      <span class="reserved">else</span> {
        <span class="reserved">this</span>.firstChild = newChild.childNodes._nodes[0];
      }

      <span class="reserved">if</span> (oldChild.nextSibling) {
        oldChild.nextSibling.previousSibling = newChild;
      }
      <span class="reserved">else</span> {
        <span class="reserved">this</span>.lastChild = newChild.childNodes._nodes[newChild.childNodes._nodes.length-1];
      }

      newChild.childNodes._nodes[0].previousSibling = oldChild.previousSibling;
      newChild.childNodes._nodes[newChild.childNodes._nodes.length-1].nextSibling = oldChild.nextSibling;
    }
  }
  <span class="reserved">else</span> {
    <span class="comment">// do node pointer surgery for newChild</span>
    newChild.parentNode = <span class="reserved">this</span>;

    <span class="reserved">if</span> (oldChild.previousSibling) {
      oldChild.previousSibling.nextSibling = newChild;
    }
    <span class="reserved">else</span> {
      <span class="reserved">this</span>.firstChild = newChild;
    }
    <span class="reserved">if</span> (oldChild.nextSibling) {
      oldChild.nextSibling.previousSibling = newChild;
    }
    <span class="reserved">else</span> {
      <span class="reserved">this</span>.lastChild = newChild;
    }
    newChild.previousSibling = oldChild.previousSibling;
    newChild.nextSibling = oldChild.nextSibling;
  }
  <span class="reserved">return</span> ret;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.removeChild - Removes the child node indicated by oldChild from the list of children, and returns it.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  oldChild : DOMNode - The node being removed.
 *
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this Node is readonly.
 * <span class="attrib">@throws</span> : DOMException - NOT_FOUND_ERR: Raised if there is no node named name in this map.
 *
 * <span class="attrib">@return</span> : DOMNode - The node being removed.
 */</span>
DOMNode.<span class="reserved">prototype</span>.removeChild = <span class="reserved">function</span> DOMNode_removeChild(oldChild) {
  <span class="comment">// throw Exception if DOMNamedNodeMap is readonly</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; (<span class="reserved">this</span>._readonly || oldChild._readonly)) {
    throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
  }

  <span class="comment">// get index of oldChild</span>
  var itemIndex = <span class="reserved">this</span>.childNodes._findItemIndex(oldChild._id);

  <span class="comment">// throw Exception if there is no child node with this id</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; (itemIndex &lt; 0)) {
    throw(new DOMException(DOMException.NOT_FOUND_ERR));
  }

  <span class="comment">// remove oldChild from childNodes</span>
  <span class="reserved">this</span>.childNodes._removeChild(itemIndex);

  <span class="comment">// do node pointer surgery</span>
  oldChild.parentNode = null;

  <span class="reserved">if</span> (oldChild.previousSibling) {
    oldChild.previousSibling.nextSibling = oldChild.nextSibling;
  }
  <span class="reserved">else</span> {
    <span class="reserved">this</span>.firstChild = oldChild.nextSibling;
  }
  <span class="reserved">if</span> (oldChild.nextSibling) {
    oldChild.nextSibling.previousSibling = oldChild.previousSibling;
  }
  <span class="reserved">else</span> {
    <span class="reserved">this</span>.lastChild = oldChild.previousSibling;
  }

  oldChild.previousSibling = null;
  oldChild.nextSibling = null;
  <span class="reserved">return</span> oldChild;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.appendChild - Adds the node newChild to the end of the list of children of this node.
 *   If the newChild is already in the tree, it is first removed.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  newChild : DOMNode - The node to add
 *
 * <span class="attrib">@throws</span> : DOMException - HIERARCHY_REQUEST_ERR: Raised if the node to insert is one of this node's ancestors
 * <span class="attrib">@throws</span> : DOMException - WRONG_DOCUMENT_ERR: Raised if arg was created from a different document than the one that created this map.
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this Node is readonly.
 *
 * <span class="attrib">@return</span> : DOMNode - The node added
 */</span>
DOMNode.<span class="reserved">prototype</span>.appendChild = <span class="reserved">function</span> DOMNode_appendChild(newChild) {
  <span class="comment">// test for exceptions</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking) {
    <span class="comment">// throw Exception if Node is readonly</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>._readonly) {
      throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
    }

    <span class="comment">// throw Exception if arg was not created by this Document</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument != newChild.ownerDocument) {
      throw(new DOMException(DOMException.WRONG_DOCUMENT_ERR));
    }

    <span class="comment">// throw Exception if the node is an ancestor</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>._isAncestor(newChild)) {
      throw(new DOMException(DOMException.HIERARCHY_REQUEST_ERR));
    }
  }

  <span class="comment">// if the newChild is already in the tree,</span>
  var newChildParent = newChild.parentNode;
  <span class="reserved">if</span> (newChildParent) {
    <span class="comment">// remove it</span>
    newChildParent.removeChild(newChild);
  }

  <span class="comment">// add newChild to childNodes</span>
  <span class="reserved">this</span>.childNodes._appendChild(newChild);

  <span class="reserved">if</span> (newChild.nodeType == DOMNode.DOCUMENT_FRAGMENT_NODE) {
    <span class="comment">// do node pointer surgery for DocumentFragment</span>
    <span class="reserved">if</span> (newChild.childNodes._nodes.length &gt; 0) {
      <span class="reserved">for</span> (var ind = 0; ind &lt; newChild.childNodes._nodes.length; ind++) {
        newChild.childNodes._nodes[ind].parentNode = <span class="reserved">this</span>;
      }

      <span class="reserved">if</span> (<span class="reserved">this</span>.lastChild) {
        <span class="reserved">this</span>.lastChild.nextSibling = newChild.childNodes._nodes[0];
        newChild.childNodes._nodes[0].previousSibling = <span class="reserved">this</span>.lastChild;
        <span class="reserved">this</span>.lastChild = newChild.childNodes._nodes[newChild.childNodes._nodes.length-1];
      }
      <span class="reserved">else</span> {
        <span class="reserved">this</span>.lastChild = newChild.childNodes._nodes[newChild.childNodes._nodes.length-1];
        <span class="reserved">this</span>.firstChild = newChild.childNodes._nodes[0];
      }
    }
  }
  <span class="reserved">else</span> {
    <span class="comment">// do node pointer surgery for newChild</span>
    newChild.parentNode = <span class="reserved">this</span>;
    <span class="reserved">if</span> (<span class="reserved">this</span>.lastChild) {
      <span class="reserved">this</span>.lastChild.nextSibling = newChild;
      newChild.previousSibling = <span class="reserved">this</span>.lastChild;
      <span class="reserved">this</span>.lastChild = newChild;
    }
    <span class="reserved">else</span> {
      <span class="reserved">this</span>.lastChild = newChild;
      <span class="reserved">this</span>.firstChild = newChild;
    }
  }

  <span class="reserved">return</span> newChild;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.hasChildNodes - This is a convenience method to allow easy determination of whether a node has any children.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : boolean - true if the node has any children, false if the node has no children
 */</span>
DOMNode.<span class="reserved">prototype</span>.hasChildNodes = <span class="reserved">function</span> DOMNode_hasChildNodes() {
  <span class="reserved">return</span> (<span class="reserved">this</span>.childNodes.length &gt; 0);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.cloneNode - Returns a duplicate of this node, i.e., serves as a generic copy constructor for nodes.
 *   The duplicate node has no parent (parentNode returns null.).
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  deep : boolean - If true, recursively clone the subtree under the specified node;
 *   if false, clone only the node itself (and its attributes, if it is an Element).
 *
 * <span class="attrib">@return</span> : DOMNode
 */</span>
DOMNode.<span class="reserved">prototype</span>.cloneNode = <span class="reserved">function</span> DOMNode_cloneNode(deep) {
  <span class="comment">// use importNode to clone this Node</span>
  <span class="comment">//do not throw any exceptions</span>
  try {
     <span class="reserved">return</span> <span class="reserved">this</span>.ownerDocument.importNode(<span class="reserved">this</span>, deep);
  }
  catch (e) {
     <span class="comment">//there shouldn't be any exceptions, but if there are, return null</span>
     <span class="reserved">return</span> null;
  }
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.normalize - Puts all Text nodes in the full depth of the sub-tree underneath this Element into a "normal" form
 *   where only markup (e.g., tags, comments, processing instructions, CDATA sections, and entity references) separates Text nodes,
 *   i.e., there are no adjacent Text nodes.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au), David Joham (djoham<span class="attrib">@yahoo</span>.com) and Scott Severtson
 */</span>
DOMNode.<span class="reserved">prototype</span>.normalize = <span class="reserved">function</span> DOMNode_normalize() {
  var inode;
  var nodesToRemove = new DOMNodeList();

  <span class="reserved">if</span> (<span class="reserved">this</span>.nodeType == DOMNode.ELEMENT_NODE || <span class="reserved">this</span>.nodeType == DOMNode.DOCUMENT_NODE) {
    var adjacentTextNode = null;

    <span class="comment">// loop through all childNodes</span>
    <span class="reserved">for</span>(var i = 0; i &lt; <span class="reserved">this</span>.childNodes.length; i++) {
      inode = <span class="reserved">this</span>.childNodes.item(i);

      <span class="reserved">if</span> (inode.nodeType == DOMNode.TEXT_NODE) { <span class="comment">// this node is a text node</span>
        <span class="reserved">if</span> (inode.length &lt; 1) {                  <span class="comment">// this text node is empty</span>
          nodesToRemove._appendChild(inode);      <span class="comment">// add this node to the list of nodes to be remove</span>
        }
        <span class="reserved">else</span> {
          <span class="reserved">if</span> (adjacentTextNode) {                <span class="comment">// if previous node was also text</span>
            adjacentTextNode.appendData(inode.data);     <span class="comment">// merge the data in adjacent text nodes</span>
            nodesToRemove._appendChild(inode);    <span class="comment">// add this node to the list of nodes to be removed</span>
          }
          <span class="reserved">else</span> {
              adjacentTextNode = inode;              <span class="comment">// remember this node for next cycle</span>
          }
        }
      }
      <span class="reserved">else</span> {
        adjacentTextNode = null;                 <span class="comment">// (soon to be) previous node is not a text node</span>
        inode.normalize();                       <span class="comment">// normalise non Text childNodes</span>
      }
    }

    <span class="comment">// remove redundant Text Nodes</span>
    <span class="reserved">for</span>(var i = 0; i &lt; nodesToRemove.length; i++) {
      inode = nodesToRemove.item(i);
      inode.parentNode.removeChild(inode);
    }
  }
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.isSupported - Test if the DOM implementation implements a specific feature
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  feature : string - The package name of the feature to test. the legal only values are "XML" and "CORE" (case-insensitive).
 * <span class="attrib">@param</span>  version : string - This is the version number of the package name to test. In Level 1, this is the string "1.0".
 *
 * <span class="attrib">@return</span> : boolean
 */</span>
DOMNode.<span class="reserved">prototype</span>.isSupported = <span class="reserved">function</span> DOMNode_isSupported(feature, version) {
  <span class="comment">// use Implementation.hasFeature to determin if this feature is supported</span>
  <span class="reserved">return</span> <span class="reserved">this</span>.ownerDocument.implementation.hasFeature(feature, version);
}

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.getElementsByTagName - Returns a NodeList of all the Elements with a given tag name
 *   in the order in which they would be encountered in a preorder traversal of the Document tree.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  tagname : string - The name of the tag to match on. The special value "*" matches all tags
 *
 * <span class="attrib">@return</span> : DOMNodeList
 */</span>
DOMNode.<span class="reserved">prototype</span>.getElementsByTagName = <span class="reserved">function</span> DOMNode_getElementsByTagName(tagname) {
  <span class="comment">// delegate to _getElementsByTagNameRecursive</span>
  <span class="reserved">return</span> <span class="reserved">this</span>._getElementsByTagNameRecursive(tagname, new DOMNodeList(<span class="reserved">this</span>.ownerDocument));
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode._getElementsByTagNameRecursive - implements getElementsByTagName()
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au), David Joham (djoham<span class="attrib">@yahoo</span>.com) and Scott Severtson
 *
 * <span class="attrib">@param</span>  tagname  : string      - The name of the tag to match on. The special value "*" matches all tags
 * <span class="attrib">@param</span>  nodeList : DOMNodeList - The accumulating list of matching nodes
 *
 * <span class="attrib">@return</span> : DOMNodeList
 */</span>
DOMNode.<span class="reserved">prototype</span>._getElementsByTagNameRecursive = <span class="reserved">function</span> DOMNode__getElementsByTagNameRecursive(tagname, nodeList) {
  <span class="reserved">if</span> (<span class="reserved">this</span>.nodeType == DOMNode.ELEMENT_NODE || <span class="reserved">this</span>.nodeType == DOMNode.DOCUMENT_NODE) {

    <span class="reserved">if</span>((<span class="reserved">this</span>.nodeName == tagname) || (tagname == <span class="literal">"*"</span>)) {
      nodeList._appendChild(<span class="reserved">this</span>);               <span class="comment">// add matching node to nodeList</span>
    }

    <span class="comment">// recurse childNodes</span>
    <span class="reserved">for</span>(var i = 0; i &lt; <span class="reserved">this</span>.childNodes.length; i++) {
      nodeList = <span class="reserved">this</span>.childNodes.item(i)._getElementsByTagNameRecursive(tagname, nodeList);
    }
  }

  <span class="reserved">return</span> nodeList;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.getXML - Returns the String XML of the node and all of its children
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au) and David Joham (djoham<span class="attrib">@yahoo</span>.com)
 *
 * <span class="attrib">@return</span> : string - XML String of the XML of the node and all of its children
 */</span>
DOMNode.<span class="reserved">prototype</span>.getXML = <span class="reserved">function</span> DOMNode_getXML() {
  <span class="reserved">return</span> <span class="reserved">this</span>.toString();
}


<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.getElementsByTagNameNS - Returns a NodeList of all the Elements with a given namespaceURI and localName
 *   in the order in which they would be encountered in a preorder traversal of the Document tree.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  namespaceURI : string - the namespace URI of the required node
 * <span class="attrib">@param</span>  localName    : string - the local name of the required node
 *
 * <span class="attrib">@return</span> : DOMNodeList
 */</span>
DOMNode.<span class="reserved">prototype</span>.getElementsByTagNameNS = <span class="reserved">function</span> DOMNode_getElementsByTagNameNS(namespaceURI, localName) {
  <span class="comment">// delegate to _getElementsByTagNameNSRecursive</span>
  <span class="reserved">return</span> <span class="reserved">this</span>._getElementsByTagNameNSRecursive(namespaceURI, localName, new DOMNodeList(<span class="reserved">this</span>.ownerDocument));
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode._getElementsByTagNameNSRecursive - implements getElementsByTagName()
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au), David Joham (djoham<span class="attrib">@yahoo</span>.com) and Scott Severtson
 *
 * <span class="attrib">@param</span>  namespaceURI : string - the namespace URI of the required node
 * <span class="attrib">@param</span>  localName    : string - the local name of the required node
 * <span class="attrib">@param</span>  nodeList     : DOMNodeList - The accumulating list of matching nodes
 *
 * <span class="attrib">@return</span> : DOMNodeList
 */</span>
DOMNode.<span class="reserved">prototype</span>._getElementsByTagNameNSRecursive = <span class="reserved">function</span> DOMNode__getElementsByTagNameNSRecursive(namespaceURI, localName, nodeList) {
  <span class="reserved">if</span> (<span class="reserved">this</span>.nodeType == DOMNode.ELEMENT_NODE || <span class="reserved">this</span>.nodeType == DOMNode.DOCUMENT_NODE) {

    <span class="reserved">if</span> (((<span class="reserved">this</span>.namespaceURI == namespaceURI) || (namespaceURI == <span class="literal">"*"</span>)) &amp;&amp; ((<span class="reserved">this</span>.localName == localName) || (localName == <span class="literal">"*"</span>))) {
      nodeList._appendChild(<span class="reserved">this</span>);               <span class="comment">// add matching node to nodeList</span>
    }

    <span class="comment">// recurse childNodes</span>
    <span class="reserved">for</span>(var i = 0; i &lt; <span class="reserved">this</span>.childNodes.length; i++) {
      nodeList = <span class="reserved">this</span>.childNodes.item(i)._getElementsByTagNameNSRecursive(namespaceURI, localName, nodeList);
    }
  }

  <span class="reserved">return</span> nodeList;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode._isAncestor - returns true if node is ancestor of this
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au), David Joham (djoham<span class="attrib">@yahoo</span>.com) and Scott Severtson
 *
 * <span class="attrib">@param</span>  node         : DOMNode - The candidate ancestor node
 *
 * <span class="attrib">@return</span> : boolean
 */</span>
DOMNode.<span class="reserved">prototype</span>._isAncestor = <span class="reserved">function</span> DOMNode__isAncestor(node) {
  <span class="comment">// if this node matches, return true,</span>
  <span class="comment">// otherwise recurse up (if there is a parentNode)</span>
  <span class="reserved">return</span> ((<span class="reserved">this</span> == node) || ((<span class="reserved">this</span>.parentNode) &amp;&amp; (<span class="reserved">this</span>.parentNode._isAncestor(node))));
}

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.importNode - Imports a node from another document to this document.
 *   The returned node has no parent; (parentNode is null).
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  importedNode : Node - The Node to be imported
 * <span class="attrib">@param</span>  deep         : boolean - If true, recursively clone the subtree under the specified node;
 *   if false, clone only the node itself (and its attributes, if it is an Element).
 *
 * <span class="attrib">@return</span> : DOMNode
 */</span>
DOMNode.<span class="reserved">prototype</span>.importNode = <span class="reserved">function</span> DOMNode_importNode(importedNode, deep) {
  var importNode;

  <span class="comment">//there is no need to perform namespace checks since everything has already gone through them</span>
  <span class="comment">//in order to have gotten into the DOM in the first place. The following line</span>
  <span class="comment">//turns namespace checking off in ._isValidNamespace</span>
  <span class="reserved">this</span>.getOwnerDocument()._performingImportNodeOperation = true;

  try {
    <span class="reserved">if</span> (importedNode.nodeType == DOMNode.ELEMENT_NODE) {
        <span class="reserved">if</span> (!<span class="reserved">this</span>.ownerDocument.implementation.namespaceAware) {
        <span class="comment">// create a local Element (with the name of the importedNode)</span>
        importNode = <span class="reserved">this</span>.ownerDocument.createElement(importedNode.tagName);

        <span class="comment">// create attributes matching those of the importedNode</span>
        <span class="reserved">for</span>(var i = 0; i &lt; importedNode.attributes.length; i++) {
            importNode.setAttribute(importedNode.attributes.item(i).name, importedNode.attributes.item(i).value);
        }
        }
        <span class="reserved">else</span> {
        <span class="comment">// create a local Element (with the name &amp; namespaceURI of the importedNode)</span>
        importNode = <span class="reserved">this</span>.ownerDocument.createElementNS(importedNode.namespaceURI, importedNode.nodeName);

        <span class="comment">// create attributes matching those of the importedNode</span>
        <span class="reserved">for</span>(var i = 0; i &lt; importedNode.attributes.length; i++) {
            importNode.setAttributeNS(importedNode.attributes.item(i).namespaceURI, importedNode.attributes.item(i).name, importedNode.attributes.item(i).value);
        }

        <span class="comment">// create namespace definitions matching those of the importedNode</span>
        <span class="reserved">for</span>(var i = 0; i &lt; importedNode._namespaces.length; i++) {
            importNode._namespaces._nodes[i] = <span class="reserved">this</span>.ownerDocument.createNamespace(importedNode._namespaces.item(i).localName);
            importNode._namespaces._nodes[i].setValue(importedNode._namespaces.item(i).value);
        }
        }
    }
    <span class="reserved">else</span> <span class="reserved">if</span> (importedNode.nodeType == DOMNode.ATTRIBUTE_NODE) {
        <span class="reserved">if</span> (!<span class="reserved">this</span>.ownerDocument.implementation.namespaceAware) {
        <span class="comment">// create a local Attribute (with the name of the importedAttribute)</span>
        importNode = <span class="reserved">this</span>.ownerDocument.createAttribute(importedNode.name);
        }
        <span class="reserved">else</span> {
        <span class="comment">// create a local Attribute (with the name &amp; namespaceURI of the importedAttribute)</span>
        importNode = <span class="reserved">this</span>.ownerDocument.createAttributeNS(importedNode.namespaceURI, importedNode.nodeName);

        <span class="comment">// create namespace definitions matching those of the importedAttribute</span>
        <span class="reserved">for</span>(var i = 0; i &lt; importedNode._namespaces.length; i++) {
            importNode._namespaces._nodes[i] = <span class="reserved">this</span>.ownerDocument.createNamespace(importedNode._namespaces.item(i).localName);
            importNode._namespaces._nodes[i].setValue(importedNode._namespaces.item(i).value);
        }
        }

        <span class="comment">// set the value of the local Attribute to match that of the importedAttribute</span>
        importNode.setValue(importedNode.value);
    }
    <span class="reserved">else</span> <span class="reserved">if</span> (importedNode.nodeType == DOMNode.DOCUMENT_FRAGMENT) {
        <span class="comment">// create a local DocumentFragment</span>
        importNode = <span class="reserved">this</span>.ownerDocument.createDocumentFragment();
    }
    <span class="reserved">else</span> <span class="reserved">if</span> (importedNode.nodeType == DOMNode.NAMESPACE_NODE) {
        <span class="comment">// create a local NamespaceNode (with the same name &amp; value as the importedNode)</span>
        importNode = <span class="reserved">this</span>.ownerDocument.createNamespace(importedNode.nodeName);
        importNode.setValue(importedNode.value);
    }
    <span class="reserved">else</span> <span class="reserved">if</span> (importedNode.nodeType == DOMNode.TEXT_NODE) {
        <span class="comment">// create a local TextNode (with the same data as the importedNode)</span>
        importNode = <span class="reserved">this</span>.ownerDocument.createTextNode(importedNode.data);
    }
    <span class="reserved">else</span> <span class="reserved">if</span> (importedNode.nodeType == DOMNode.CDATA_SECTION_NODE) {
        <span class="comment">// create a local CDATANode (with the same data as the importedNode)</span>
        importNode = <span class="reserved">this</span>.ownerDocument.createCDATASection(importedNode.data);
    }
    <span class="reserved">else</span> <span class="reserved">if</span> (importedNode.nodeType == DOMNode.PROCESSING_INSTRUCTION_NODE) {
        <span class="comment">// create a local ProcessingInstruction (with the same target &amp; data as the importedNode)</span>
        importNode = <span class="reserved">this</span>.ownerDocument.createProcessingInstruction(importedNode.target, importedNode.data);
    }
    <span class="reserved">else</span> <span class="reserved">if</span> (importedNode.nodeType == DOMNode.COMMENT_NODE) {
        <span class="comment">// create a local Comment (with the same data as the importedNode)</span>
        importNode = <span class="reserved">this</span>.ownerDocument.createComment(importedNode.data);
    }
    <span class="reserved">else</span> {  <span class="comment">// throw Exception if nodeType is not supported</span>
        throw(new DOMException(DOMException.NOT_SUPPORTED_ERR));
    }

    <span class="reserved">if</span> (deep) {                                    <span class="comment">// recurse childNodes</span>
        <span class="reserved">for</span>(var i = 0; i &lt; importedNode.childNodes.length; i++) {
        importNode.appendChild(<span class="reserved">this</span>.ownerDocument.importNode(importedNode.childNodes.item(i), true));
        }
    }

    <span class="comment">//reset _performingImportNodeOperation</span>
    <span class="reserved">this</span>.getOwnerDocument()._performingImportNodeOperation = false;
    <span class="reserved">return</span> importNode;
  }
  catch (eAny) {
    <span class="comment">//reset _performingImportNodeOperation</span>
    <span class="reserved">this</span>.getOwnerDocument()._performingImportNodeOperation = false;

    <span class="comment">//re-throw the exception</span>
    throw eAny;
  }<span class="comment">//djotemp</span>
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.escapeString - escape special characters
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  str : string - The string to be escaped
 *
 * <span class="attrib">@return</span> : string - The escaped string
 */</span>
DOMNode.<span class="reserved">prototype</span>.__escapeString = <span class="reserved">function</span> DOMNode__escapeString(str) {

  <span class="comment">//the sax processor already has this function. Just wrap it</span>
  <span class="reserved">return</span> __escapeString(str);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNode.unescapeString - unescape special characters
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  str : string - The string to be unescaped
 *
 * <span class="attrib">@return</span> : string - The unescaped string
 */</span>
DOMNode.<span class="reserved">prototype</span>.__unescapeString = <span class="reserved">function</span> DOMNode__unescapeString(str) {

  <span class="comment">//the sax processor already has this function. Just wrap it</span>
  <span class="reserved">return</span> __unescapeString(str);
};



<span class="comment">/**
 * <span class="attrib">@class</span>  DOMDocument - The Document interface represents the entire HTML or XML document.
 *   Conceptually, it is the root of the document tree, and provides the primary access to the document's data.
 *
 * <span class="attrib">@extends</span> DOMNode
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  implementation : DOMImplementation - the creator Implementation
 */</span>
DOMDocument = <span class="reserved">function</span>(implementation) {
  <span class="reserved">this</span>._class = addClass(<span class="reserved">this</span>._class, <span class="literal">"DOMDocument"</span>);
  <span class="reserved">this</span>.DOMNode = DOMNode;
  <span class="reserved">this</span>.DOMNode(<span class="reserved">this</span>);

  <span class="reserved">this</span>.doctype = null;                           <span class="comment">// The Document Type Declaration (see DocumentType) associated with this document</span>
  <span class="reserved">this</span>.implementation = implementation;          <span class="comment">// The DOMImplementation object that handles this document.</span>
  <span class="reserved">this</span>.documentElement = null;                   <span class="comment">// This is a convenience attribute that allows direct access to the child node that is the root element of the document</span>
  <span class="reserved">this</span>.all  = new Array();                       <span class="comment">// The list of all Elements</span>

  <span class="reserved">this</span>.nodeName  = <span class="literal">"#document"</span>;
  <span class="reserved">this</span>.nodeType = DOMNode.DOCUMENT_NODE;
  <span class="reserved">this</span>._id = 0;
  <span class="reserved">this</span>._lastId = 0;
  <span class="reserved">this</span>._parseComplete = false;                   <span class="comment">// initially false, set to true by parser</span>

  <span class="reserved">this</span>.ownerDocument = <span class="reserved">this</span>;

  <span class="reserved">this</span>._performingImportNodeOperation = false;
};
DOMDocument.<span class="reserved">prototype</span> = new DOMNode;

<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocument.getDoctype - Java style gettor for .doctype
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : DOMDocument
 */</span>
DOMDocument.<span class="reserved">prototype</span>.getDoctype = <span class="reserved">function</span> DOMDocument_getDoctype() {
  <span class="reserved">return</span> <span class="reserved">this</span>.doctype;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocument.getImplementation - Java style gettor for .implementation
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : DOMImplementation
 */</span>
DOMDocument.<span class="reserved">prototype</span>.getImplementation = <span class="reserved">function</span> DOMDocument_implementation() {
  <span class="reserved">return</span> <span class="reserved">this</span>.implementation;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocument.getDocumentElement - Java style gettor for .documentElement
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : DOMDocumentElement
 */</span>
DOMDocument.<span class="reserved">prototype</span>.getDocumentElement = <span class="reserved">function</span> DOMDocument_getDocumentElement() {
  <span class="reserved">return</span> <span class="reserved">this</span>.documentElement;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocument.createElement - Creates an element of the type specified.
 *   Note that the instance returned implements the Element interface,
 *   so attributes can be specified directly on the returned object.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  tagName : string - The name of the element type to instantiate.
 *
 * <span class="attrib">@throws</span> : DOMException - INVALID_CHARACTER_ERR: Raised if the string contains an illegal character
 *
 * <span class="attrib">@return</span> : DOMElement - The new Element object.
 */</span>
DOMDocument.<span class="reserved">prototype</span>.createElement = <span class="reserved">function</span> DOMDocument_createElement(tagName) {
  <span class="comment">// throw Exception if the tagName string contains an illegal character</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; (!<span class="reserved">this</span>.ownerDocument.implementation._isValidName(tagName))) {
    throw(new DOMException(DOMException.INVALID_CHARACTER_ERR));
  }

  <span class="comment">// create DOMElement specifying 'this' as ownerDocument</span>
  var node = new DOMElement(<span class="reserved">this</span>);

  <span class="comment">// assign values to properties (and aliases)</span>
  node.tagName  = tagName;
  node.nodeName = tagName;

  <span class="comment">// add Element to 'all' collection</span>
  <span class="reserved">this</span>.all[<span class="reserved">this</span>.all.length] = node;

  <span class="reserved">return</span> node;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocument.createDocumentFragment - CCreates an empty DocumentFragment object.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : DOMDocumentFragment - The new DocumentFragment object
 */</span>
DOMDocument.<span class="reserved">prototype</span>.createDocumentFragment = <span class="reserved">function</span> DOMDocument_createDocumentFragment() {
  <span class="comment">// create DOMDocumentFragment specifying 'this' as ownerDocument</span>
  var node = new DOMDocumentFragment(<span class="reserved">this</span>);

  <span class="reserved">return</span> node;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocument.createTextNode - Creates a Text node given the specified string.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  data : string - The data for the node.
 *
 * <span class="attrib">@return</span> : DOMText - The new Text object.
 */</span>
DOMDocument.<span class="reserved">prototype</span>.createTextNode = <span class="reserved">function</span> DOMDocument_createTextNode(data) {
  <span class="comment">// create DOMText specifying 'this' as ownerDocument</span>
  var node = new DOMText(<span class="reserved">this</span>);

  <span class="comment">// assign values to properties (and aliases)</span>
  node.data      = data;
  node.nodeValue = data;

  <span class="comment">// set initial length</span>
  node.length    = data.length;

  <span class="reserved">return</span> node;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocument.createComment - Creates a Text node given the specified string.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  data : string - The data for the node.
 *
 * <span class="attrib">@return</span> : DOMComment - The new Comment object.
 */</span>
DOMDocument.<span class="reserved">prototype</span>.createComment = <span class="reserved">function</span> DOMDocument_createComment(data) {
  <span class="comment">// create DOMComment specifying 'this' as ownerDocument</span>
  var node = new DOMComment(<span class="reserved">this</span>);

  <span class="comment">// assign values to properties (and aliases)</span>
  node.data      = data;
  node.nodeValue = data;

  <span class="comment">// set initial length</span>
  node.length    = data.length;

  <span class="reserved">return</span> node;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocument.createCDATASection - Creates a CDATASection node whose value is the specified string.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  data : string - The data for the node.
 *
 * <span class="attrib">@return</span> : DOMCDATASection - The new CDATASection object.
 */</span>
DOMDocument.<span class="reserved">prototype</span>.createCDATASection = <span class="reserved">function</span> DOMDocument_createCDATASection(data) {
  <span class="comment">// create DOMCDATASection specifying 'this' as ownerDocument</span>
  var node = new DOMCDATASection(<span class="reserved">this</span>);

  <span class="comment">// assign values to properties (and aliases)</span>
  node.data      = data;
  node.nodeValue = data;

  <span class="comment">// set initial length</span>
  node.length    = data.length;

  <span class="reserved">return</span> node;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocument.createProcessingInstruction - Creates a ProcessingInstruction node given the specified target and data strings.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  target : string - The target part of the processing instruction.
 * <span class="attrib">@param</span>  data   : string - The data for the node.
 *
 * <span class="attrib">@throws</span> : DOMException - INVALID_CHARACTER_ERR: Raised if the string contains an illegal character
 *
 * <span class="attrib">@return</span> : DOMProcessingInstruction - The new ProcessingInstruction object.
 */</span>
DOMDocument.<span class="reserved">prototype</span>.createProcessingInstruction = <span class="reserved">function</span> DOMDocument_createProcessingInstruction(target, data) {
  <span class="comment">// throw Exception if the target string contains an illegal character</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; (!<span class="reserved">this</span>.implementation._isValidName(target))) {
    throw(new DOMException(DOMException.INVALID_CHARACTER_ERR));
  }

  <span class="comment">// create DOMProcessingInstruction specifying 'this' as ownerDocument</span>
  var node = new DOMProcessingInstruction(<span class="reserved">this</span>);

  <span class="comment">// assign values to properties (and aliases)</span>
  node.target    = target;
  node.nodeName  = target;
  node.data      = data;
  node.nodeValue = data;

  <span class="comment">// set initial length</span>
  node.length    = data.length;

  <span class="reserved">return</span> node;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocument.createAttribute - Creates an Attr of the given name
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  name : string - The name of the attribute.
 *
 * <span class="attrib">@throws</span> : DOMException - INVALID_CHARACTER_ERR: Raised if the string contains an illegal character
 *
 * <span class="attrib">@return</span> : DOMAttr - The new Attr object.
 */</span>
DOMDocument.<span class="reserved">prototype</span>.createAttribute = <span class="reserved">function</span> DOMDocument_createAttribute(name) {
  <span class="comment">// throw Exception if the name string contains an illegal character</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; (!<span class="reserved">this</span>.ownerDocument.implementation._isValidName(name))) {
    throw(new DOMException(DOMException.INVALID_CHARACTER_ERR));
  }

  <span class="comment">// create DOMAttr specifying 'this' as ownerDocument</span>
  var node = new DOMAttr(<span class="reserved">this</span>);

  <span class="comment">// assign values to properties (and aliases)</span>
  node.name     = name;
  node.nodeName = name;

  <span class="reserved">return</span> node;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocument.createElementNS - Creates an element of the type specified,
 *   within the specified namespace.
 *   Note that the instance returned implements the Element interface,
 *   so attributes can be specified directly on the returned object.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  namespaceURI  : string - The namespace URI of the element.
 * <span class="attrib">@param</span>  qualifiedName : string - The qualified name of the element type to instantiate.
 *
 * <span class="attrib">@throws</span> : DOMException - NAMESPACE_ERR: Raised if the Namespace is invalid
 * <span class="attrib">@throws</span> : DOMException - INVALID_CHARACTER_ERR: Raised if the string contains an illegal character
 *
 * <span class="attrib">@return</span> : DOMElement - The new Element object.
 */</span>
DOMDocument.<span class="reserved">prototype</span>.createElementNS = <span class="reserved">function</span> DOMDocument_createElementNS(namespaceURI, qualifiedName) {
  <span class="comment">// test for exceptions</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking) {
    <span class="comment">// throw Exception if the Namespace is invalid</span>
    <span class="reserved">if</span> (!<span class="reserved">this</span>.ownerDocument._isValidNamespace(namespaceURI, qualifiedName)) {
      throw(new DOMException(DOMException.NAMESPACE_ERR));
    }

    <span class="comment">// throw Exception if the qualifiedName string contains an illegal character</span>
    <span class="reserved">if</span> (!<span class="reserved">this</span>.ownerDocument.implementation._isValidName(qualifiedName)) {
      throw(new DOMException(DOMException.INVALID_CHARACTER_ERR));
    }
  }

  <span class="comment">// create DOMElement specifying 'this' as ownerDocument</span>
  var node  = new DOMElement(<span class="reserved">this</span>);
  var qname = <span class="reserved">this</span>.implementation._parseQName(qualifiedName);

  <span class="comment">// assign values to properties (and aliases)</span>
  node.nodeName     = qualifiedName;
  node.namespaceURI = namespaceURI;
  node.prefix       = qname.prefix;
  node.localName    = qname.localName;
  node.tagName      = qualifiedName;

  <span class="comment">// add Element to 'all' collection</span>
  <span class="reserved">this</span>.all[<span class="reserved">this</span>.all.length] = node;

  <span class="reserved">return</span> node;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocument.createAttributeNS - Creates an Attr of the given name
 *   within the specified namespace.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  namespaceURI  : string - The namespace URI of the attribute.
 * <span class="attrib">@param</span>  qualifiedName : string - The qualified name of the attribute.
 *
 * <span class="attrib">@throws</span> : DOMException - NAMESPACE_ERR: Raised if the Namespace is invalid
 * <span class="attrib">@throws</span> : DOMException - INVALID_CHARACTER_ERR: Raised if the string contains an illegal character
 *
 * <span class="attrib">@return</span> : DOMAttr - The new Attr object.
 */</span>
DOMDocument.<span class="reserved">prototype</span>.createAttributeNS = <span class="reserved">function</span> DOMDocument_createAttributeNS(namespaceURI, qualifiedName) {
  <span class="comment">// test for exceptions</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking) {
    <span class="comment">// throw Exception if the Namespace is invalid</span>
    <span class="reserved">if</span> (!<span class="reserved">this</span>.ownerDocument._isValidNamespace(namespaceURI, qualifiedName, true)) {
      throw(new DOMException(DOMException.NAMESPACE_ERR));
    }

    <span class="comment">// throw Exception if the qualifiedName string contains an illegal character</span>
    <span class="reserved">if</span> (!<span class="reserved">this</span>.ownerDocument.implementation._isValidName(qualifiedName)) {
      throw(new DOMException(DOMException.INVALID_CHARACTER_ERR));
    }
  }

  <span class="comment">// create DOMAttr specifying 'this' as ownerDocument</span>
  var node  = new DOMAttr(<span class="reserved">this</span>);
  var qname = <span class="reserved">this</span>.implementation._parseQName(qualifiedName);

  <span class="comment">// assign values to properties (and aliases)</span>
  node.nodeName     = qualifiedName
  node.namespaceURI = namespaceURI
  node.prefix       = qname.prefix;
  node.localName    = qname.localName;
  node.name         = qualifiedName
  node.nodeValue    = <span class="literal">""</span>;

  <span class="reserved">return</span> node;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocument.createNamespace - Creates an Namespace of the given name
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  qualifiedName : string - The qualified name of the attribute.
 *
 * <span class="attrib">@return</span> : DOMNamespace - The new Namespace object.
 */</span>
DOMDocument.<span class="reserved">prototype</span>.createNamespace = <span class="reserved">function</span> DOMDocument_createNamespace(qualifiedName) {
  <span class="comment">// create DOMNamespace specifying 'this' as ownerDocument</span>
  var node  = new DOMNamespace(<span class="reserved">this</span>);
  var qname = <span class="reserved">this</span>.implementation._parseQName(qualifiedName);

  <span class="comment">// assign values to properties (and aliases)</span>
  node.nodeName     = qualifiedName
  node.prefix       = qname.prefix;
  node.localName    = qname.localName;
  node.name         = qualifiedName
  node.nodeValue    = <span class="literal">""</span>;

  <span class="reserved">return</span> node;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocument.getElementById - Return the Element whose ID is given by elementId
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  elementId : string - The unique ID of the Element
 *
 * <span class="attrib">@return</span> : DOMElement - The requested DOMElement
 */</span>
DOMDocument.<span class="reserved">prototype</span>.getElementById = <span class="reserved">function</span> DOMDocument_getElementById(elementId) {
<span class="comment">//  return this._ids[elementId];</span>
  retNode = null;

  <span class="comment">// loop through all Elements in the 'all' collection</span>
  <span class="reserved">for</span> (var i=0; i &lt; <span class="reserved">this</span>.all.length; i++) {
    var node = <span class="reserved">this</span>.all[i];

    <span class="comment">// if id matches &amp; node is alive (ie, connected (in)directly to the documentElement)</span>
    <span class="reserved">if</span> ((node.id == elementId) &amp;&amp; (node._isAncestor(node.ownerDocument.documentElement))) {
      retNode = node;
      break;
    }
  }

  <span class="reserved">return</span> retNode;
};



<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocument._genId - generate a unique internal id
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : string - The unique (serial) id
 */</span>
DOMDocument.<span class="reserved">prototype</span>._genId = <span class="reserved">function</span> DOMDocument__genId() {
  <span class="reserved">this</span>._lastId += 1;                             <span class="comment">// increment lastId (to generate unique id)</span>

  <span class="reserved">return</span> <span class="reserved">this</span>._lastId;
};


<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocument._isValidNamespace - test if Namespace is valid
 *  ie, not valid if;
 *    the qualifiedName is malformed, or
 *    the qualifiedName has a prefix and the namespaceURI is null, or
 *    the qualifiedName has a prefix that is "xml" and the namespaceURI is
 *     different from "http://www.w3.org/XML/1998/namespace" [Namespaces].
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au), David Joham (djoham<span class="attrib">@yahoo</span>.com) and Scott Severtson
 *
 * <span class="attrib">@param</span>  namespaceURI  : string - the namespace URI
 * <span class="attrib">@param</span>  qualifiedName : string - the QName
 * <span class="attrib">@Param</span>  isAttribute   : boolean - true, if the requesting node is an Attr
 *
 * <span class="attrib">@return</span> : boolean
 */</span>
DOMDocument.<span class="reserved">prototype</span>._isValidNamespace = <span class="reserved">function</span> DOMDocument__isValidNamespace(namespaceURI, qualifiedName, isAttribute) {

  <span class="reserved">if</span> (<span class="reserved">this</span>._performingImportNodeOperation == true) {
    <span class="comment">//we're doing an importNode operation (or a cloneNode) - in both cases, there</span>
    <span class="comment">//is no need to perform any namespace checking since the nodes have to have been valid</span>
    <span class="comment">//to have gotten into the DOM in the first place</span>
    <span class="reserved">return</span> true;
  }

  var valid = true;
  <span class="comment">// parse QName</span>
  var qName = <span class="reserved">this</span>.implementation._parseQName(qualifiedName);


  <span class="comment">//only check for namespaces if we're finished parsing</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>._parseComplete == true) {

    <span class="comment">// if the qualifiedName is malformed</span>
    <span class="reserved">if</span> (qName.localName.indexOf(<span class="literal">":"</span>) &gt; -1 ){
        valid = false;
    }

    <span class="reserved">if</span> ((valid) &amp;&amp; (!isAttribute)) {
        <span class="comment">// if the namespaceURI is not null</span>
        <span class="reserved">if</span> (!namespaceURI) {
        valid = false;
        }
    }

    <span class="comment">// if the qualifiedName has a prefix</span>
    <span class="reserved">if</span> ((valid) &amp;&amp; (qName.prefix == <span class="literal">""</span>)) {
        valid = false;
    }

  }

  <span class="comment">// if the qualifiedName has a prefix that is "xml" and the namespaceURI is</span>
  <span class="comment">//  different from "http://www.w3.org/XML/1998/namespace" [Namespaces].</span>
  <span class="reserved">if</span> ((valid) &amp;&amp; (qName.prefix == <span class="literal">"xml"</span>) &amp;&amp; (namespaceURI != <span class="literal">"http://www.w3.org/XML/1998/namespace"</span>)) {
    valid = false;
  }

  <span class="reserved">return</span> valid;
}

<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocument.toString - Serialize the document into an XML string
 *
 * <span class="attrib">@author</span> David Joham (djoham<span class="attrib">@yahoo</span>.com)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMDocument.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span> DOMDocument_toString() {
  <span class="reserved">return</span> <span class="literal">""</span> + <span class="reserved">this</span>.childNodes;
} <span class="comment">// end function getXML</span>


<span class="comment">/**
 * <span class="attrib">@class</span>  DOMElement - By far the vast majority of objects (apart from text) that authors encounter
 *   when traversing a document are Element nodes.
 *
 * <span class="attrib">@extends</span> DOMNode
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  ownerDocument : DOMDocument - The Document object associated with this node.
 */</span>
DOMElement = <span class="reserved">function</span>(ownerDocument) {
  <span class="reserved">this</span>._class = addClass(<span class="reserved">this</span>._class, <span class="literal">"DOMElement"</span>);
  <span class="reserved">this</span>.DOMNode  = DOMNode;
  <span class="reserved">this</span>.DOMNode(ownerDocument);

  <span class="reserved">this</span>.tagName = <span class="literal">""</span>;                             <span class="comment">// The name of the element.</span>
  <span class="reserved">this</span>.id = <span class="literal">""</span>;                                  <span class="comment">// the ID of the element</span>

  <span class="reserved">this</span>.nodeType = DOMNode.ELEMENT_NODE;
};
DOMElement.<span class="reserved">prototype</span> = new DOMNode;

<span class="comment">/**
 * <span class="attrib">@method</span> DOMElement.getTagName - Java style gettor for .TagName
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMElement.<span class="reserved">prototype</span>.getTagName = <span class="reserved">function</span> DOMElement_getTagName() {
  <span class="reserved">return</span> <span class="reserved">this</span>.tagName;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMElement.getAttribute - Retrieves an attribute value by name
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  name : string - The name of the attribute to retrieve
 *
 * <span class="attrib">@return</span> : string - The Attr value as a string, or the empty string if that attribute does not have a specified value.
 */</span>
DOMElement.<span class="reserved">prototype</span>.getAttribute = <span class="reserved">function</span> DOMElement_getAttribute(name) {
  var ret = <span class="literal">""</span>;

  <span class="comment">// if attribute exists, use it</span>
  var attr = <span class="reserved">this</span>.attributes.getNamedItem(name);

  <span class="reserved">if</span> (attr) {
    ret = attr.value;
  }

  <span class="reserved">return</span> ret; <span class="comment">// if Attribute exists, return its value, otherwise, return ""</span>
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMElement.setAttribute - Retrieves an attribute value by name
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  name  : string - The name of the attribute to create or alter
 * <span class="attrib">@param</span>  value : string - Value to set in string form
 *
 * <span class="attrib">@throws</span> : DOMException - INVALID_CHARACTER_ERR: Raised if the string contains an illegal character
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if the Attribute is readonly.
 */</span>
DOMElement.<span class="reserved">prototype</span>.setAttribute = <span class="reserved">function</span> DOMElement_setAttribute(name, value) {
  <span class="comment">// if attribute exists, use it</span>
  var attr = <span class="reserved">this</span>.attributes.getNamedItem(name);

  <span class="reserved">if</span> (!attr) {
    attr = <span class="reserved">this</span>.ownerDocument.createAttribute(name);  <span class="comment">// otherwise create it</span>
  }

  var value = new String(value);

  <span class="comment">// test for exceptions</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking) {
    <span class="comment">// throw Exception if Attribute is readonly</span>
    <span class="reserved">if</span> (attr._readonly) {
      throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
    }

    <span class="comment">// throw Exception if the value string contains an illegal character</span>
    <span class="reserved">if</span> (!<span class="reserved">this</span>.ownerDocument.implementation._isValidString(value)) {
      throw(new DOMException(DOMException.INVALID_CHARACTER_ERR));
    }
  }

  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation._isIdDeclaration(name)) {
    <span class="reserved">this</span>.id = value;  <span class="comment">// cache ID for getElementById()</span>
  }

  <span class="comment">// assign values to properties (and aliases)</span>
  attr.value     = value;
  attr.nodeValue = value;

  <span class="comment">// update .specified</span>
  <span class="reserved">if</span> (value.length &gt; 0) {
    attr.specified = true;
  }
  <span class="reserved">else</span> {
    attr.specified = false;
  }

  <span class="comment">// add/replace Attribute in NamedNodeMap</span>
  <span class="reserved">this</span>.attributes.setNamedItem(attr);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMElement.removeAttribute - Removes an attribute by name
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  name  : string - The name of the attribute to remove
 *
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if the Attrbute is readonly.
 */</span>
DOMElement.<span class="reserved">prototype</span>.removeAttribute = <span class="reserved">function</span> DOMElement_removeAttribute(name) {
  <span class="comment">// delegate to DOMNamedNodeMap.removeNamedItem</span>
  <span class="reserved">return</span> <span class="reserved">this</span>.attributes.removeNamedItem(name);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMElement.getAttributeNode - Retrieves an Attr node by name
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  name  : string - The name of the attribute to remove
 *
 * <span class="attrib">@return</span> : DOMAttr - The Attr node with the specified attribute name or null if there is no such attribute.
 */</span>
DOMElement.<span class="reserved">prototype</span>.getAttributeNode = <span class="reserved">function</span> DOMElement_getAttributeNode(name) {
  <span class="comment">// delegate to DOMNamedNodeMap.getNamedItem</span>
  <span class="reserved">return</span> <span class="reserved">this</span>.attributes.getNamedItem(name);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMElement.setAttributeNode - Adds a new attribute
 *   If an attribute with that name is already present in the element, it is replaced by the new one
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  newAttr : DOMAttr - The attribute node to be attached
 *
 * <span class="attrib">@throws</span> : DOMException - WRONG_DOCUMENT_ERR: Raised if arg was created from a different document than the one that created this map.
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this Element is readonly.
 * <span class="attrib">@throws</span> : DOMException - INUSE_ATTRIBUTE_ERR: Raised if arg is an Attr that is already an attribute of another Element object.
 *
 * <span class="attrib">@return</span> : DOMAttr - If the newAttr attribute replaces an existing attribute with the same name,
 *   the previously existing Attr node is returned, otherwise null is returned.
 */</span>
DOMElement.<span class="reserved">prototype</span>.setAttributeNode = <span class="reserved">function</span> DOMElement_setAttributeNode(newAttr) {
  <span class="comment">// if this Attribute is an ID</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation._isIdDeclaration(newAttr.name)) {
    <span class="reserved">this</span>.id = newAttr.value;  <span class="comment">// cache ID for getElementById()</span>
  }

  <span class="comment">// delegate to DOMNamedNodeMap.setNamedItem</span>
  <span class="reserved">return</span> <span class="reserved">this</span>.attributes.setNamedItem(newAttr);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMElement.removeAttributeNode - Removes the specified attribute
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  oldAttr  : DOMAttr - The Attr node to remove from the attribute list
 *
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this Element is readonly.
 * <span class="attrib">@throws</span> : DOMException - INUSE_ATTRIBUTE_ERR: Raised if arg is an Attr that is already an attribute of another Element object.
 *
 * <span class="attrib">@return</span> : DOMAttr - The Attr node that was removed.
 */</span>
DOMElement.<span class="reserved">prototype</span>.removeAttributeNode = <span class="reserved">function</span> DOMElement_removeAttributeNode(oldAttr) {
  <span class="comment">// throw Exception if Attribute is readonly</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; oldAttr._readonly) {
    throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
  }

  <span class="comment">// get item index</span>
  var itemIndex = <span class="reserved">this</span>.attributes._findItemIndex(oldAttr._id);

  <span class="comment">// throw Exception if node does not exist in this map</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; (itemIndex &lt; 0)) {
    throw(new DOMException(DOMException.NOT_FOUND_ERR));
  }

  <span class="reserved">return</span> <span class="reserved">this</span>.attributes._removeChild(itemIndex);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMElement.getAttributeNS - Retrieves an attribute value by namespaceURI and localName
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  namespaceURI : string - the namespace URI of the required node
 * <span class="attrib">@param</span>  localName    : string - the local name of the required node
 *
 * <span class="attrib">@return</span> : string - The Attr value as a string, or the empty string if that attribute does not have a specified value.
 */</span>
DOMElement.<span class="reserved">prototype</span>.getAttributeNS = <span class="reserved">function</span> DOMElement_getAttributeNS(namespaceURI, localName) {
  var ret = <span class="literal">""</span>;

  <span class="comment">// delegate to DOMNAmedNodeMap.getNamedItemNS</span>
  var attr = <span class="reserved">this</span>.attributes.getNamedItemNS(namespaceURI, localName);


  <span class="reserved">if</span> (attr) {
    ret = attr.value;
  }

  <span class="reserved">return</span> ret;  <span class="comment">// if Attribute exists, return its value, otherwise return ""</span>
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMElement.setAttributeNS - Sets an attribute value by namespaceURI and localName
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  namespaceURI : string - the namespace URI of the required node
 * <span class="attrib">@param</span>  qualifiedName : string - the qualified name of the required node
 * <span class="attrib">@param</span>  value        : string - Value to set in string form
 *
 * <span class="attrib">@throws</span> : DOMException - INVALID_CHARACTER_ERR: Raised if the string contains an illegal character
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if the Attrbute is readonly.
 * <span class="attrib">@throws</span> : DOMException - NAMESPACE_ERR: Raised if the Namespace is invalid
 */</span>
DOMElement.<span class="reserved">prototype</span>.setAttributeNS = <span class="reserved">function</span> DOMElement_setAttributeNS(namespaceURI, qualifiedName, value) {
  <span class="comment">// call DOMNamedNodeMap.getNamedItem</span>
  var attr = <span class="reserved">this</span>.attributes.getNamedItem(namespaceURI, qualifiedName);

  <span class="reserved">if</span> (!attr) {  <span class="comment">// if Attribute exists, use it</span>
    <span class="comment">// otherwise create it</span>
    attr = <span class="reserved">this</span>.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
  }

  var value = new String(value);

  <span class="comment">// test for exceptions</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking) {
    <span class="comment">// throw Exception if Attribute is readonly</span>
    <span class="reserved">if</span> (attr._readonly) {
      throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
    }

    <span class="comment">// throw Exception if the Namespace is invalid</span>
    <span class="reserved">if</span> (!<span class="reserved">this</span>.ownerDocument._isValidNamespace(namespaceURI, qualifiedName)) {
      throw(new DOMException(DOMException.NAMESPACE_ERR));
    }

    <span class="comment">// throw Exception if the value string contains an illegal character</span>
    <span class="reserved">if</span> (!<span class="reserved">this</span>.ownerDocument.implementation._isValidString(value)) {
      throw(new DOMException(DOMException.INVALID_CHARACTER_ERR));
    }
  }

  <span class="comment">// if this Attribute is an ID</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation._isIdDeclaration(name)) {
    <span class="reserved">this</span>.id = value;  <span class="comment">// cache ID for getElementById()</span>
  }

  <span class="comment">// assign values to properties (and aliases)</span>
  attr.value     = value;
  attr.nodeValue = value;

  <span class="comment">// update .specified</span>
  <span class="reserved">if</span> (value.length &gt; 0) {
    attr.specified = true;
  }
  <span class="reserved">else</span> {
    attr.specified = false;
  }

  <span class="comment">// delegate to DOMNamedNodeMap.setNamedItem</span>
  <span class="reserved">this</span>.attributes.setNamedItemNS(attr);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMElement.removeAttributeNS - Removes an attribute by namespaceURI and localName
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  namespaceURI : string - the namespace URI of the required node
 * <span class="attrib">@param</span>  localName    : string - the local name of the required node
 *
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if the Attrbute is readonly.
 *
 * <span class="attrib">@return</span> : DOMAttr
 */</span>
DOMElement.<span class="reserved">prototype</span>.removeAttributeNS = <span class="reserved">function</span> DOMElement_removeAttributeNS(namespaceURI, localName) {
  <span class="comment">// delegate to DOMNamedNodeMap.removeNamedItemNS</span>
  <span class="reserved">return</span> <span class="reserved">this</span>.attributes.removeNamedItemNS(namespaceURI, localName);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMElement.getAttributeNodeNS - Retrieves an Attr node by namespaceURI and localName
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  namespaceURI : string - the namespace URI of the required node
 * <span class="attrib">@param</span>  localName    : string - the local name of the required node
 *
 * <span class="attrib">@return</span> : DOMAttr - The Attr node with the specified attribute name or null if there is no such attribute.
 */</span>
DOMElement.<span class="reserved">prototype</span>.getAttributeNodeNS = <span class="reserved">function</span> DOMElement_getAttributeNodeNS(namespaceURI, localName) {
  <span class="comment">// delegate to DOMNamedNodeMap.getNamedItemNS</span>
  <span class="reserved">return</span> <span class="reserved">this</span>.attributes.getNamedItemNS(namespaceURI, localName);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMElement.setAttributeNodeNS - Adds a new attribute
 *   If an attribute with that name is already present in the element, it is replaced by the new one
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  newAttr      : DOMAttr - the attribute node to be attached
 *
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if the Attrbute is readonly.
 * <span class="attrib">@throws</span> : DOMException - WRONG_DOCUMENT_ERR: Raised if arg was created from a different document than the one that created this map.
 * <span class="attrib">@throws</span> : DOMException - INUSE_ATTRIBUTE_ERR: Raised if arg is an Attr that is already an attribute of another Element object.
 *  The DOM user must explicitly clone Attr nodes to re-use them in other elements.
 *
 * <span class="attrib">@return</span> : DOMAttr - If the newAttr attribute replaces an existing attribute with the same name,
 *   the previously existing Attr node is returned, otherwise null is returned.
 */</span>
DOMElement.<span class="reserved">prototype</span>.setAttributeNodeNS = <span class="reserved">function</span> DOMElement_setAttributeNodeNS(newAttr) {
  <span class="comment">// if this Attribute is an ID</span>
  <span class="reserved">if</span> ((newAttr.prefix == <span class="literal">""</span>) &amp;&amp;  <span class="reserved">this</span>.ownerDocument.implementation._isIdDeclaration(newAttr.name)) {
    <span class="reserved">this</span>.id = newAttr.value;  <span class="comment">// cache ID for getElementById()</span>
  }

  <span class="comment">// delegate to DOMNamedNodeMap.setNamedItemNS</span>
  <span class="reserved">return</span> <span class="reserved">this</span>.attributes.setNamedItemNS(newAttr);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMElement.hasAttribute - Returns true if specified node exists
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  name : string - the name of the required node
 *
 * <span class="attrib">@return</span> : boolean
 */</span>
DOMElement.<span class="reserved">prototype</span>.hasAttribute = <span class="reserved">function</span> DOMElement_hasAttribute(name) {
  <span class="comment">// delegate to DOMNamedNodeMap._hasAttribute</span>
  <span class="reserved">return</span> <span class="reserved">this</span>.attributes._hasAttribute(name);
}

<span class="comment">/**
 * <span class="attrib">@method</span> DOMElement.hasAttributeNS - Returns true if specified node exists
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  namespaceURI : string - the namespace URI of the required node
 * <span class="attrib">@param</span>  localName    : string - the local name of the required node
 *
 * <span class="attrib">@return</span> : boolean
 */</span>
DOMElement.<span class="reserved">prototype</span>.hasAttributeNS = <span class="reserved">function</span> DOMElement_hasAttributeNS(namespaceURI, localName) {
  <span class="comment">// delegate to DOMNamedNodeMap._hasAttributeNS</span>
  <span class="reserved">return</span> <span class="reserved">this</span>.attributes._hasAttributeNS(namespaceURI, localName);
}

<span class="comment">/**
 * <span class="attrib">@method</span> DOMElement.toString - Serialize this Element and its children into an XML string
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au) and David Joham (djoham<span class="attrib">@yahoo</span>.com)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMElement.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span> DOMElement_toString() {
  var ret = <span class="literal">""</span>;

  <span class="comment">// serialize namespace declarations</span>
  var ns = <span class="reserved">this</span>._namespaces.toString();
  <span class="reserved">if</span> (ns.length &gt; 0) ns = <span class="literal">" "</span>+ ns;

  <span class="comment">// serialize Attribute declarations</span>
  var attrs = <span class="reserved">this</span>.attributes.toString();
  <span class="reserved">if</span> (attrs.length &gt; 0) attrs = <span class="literal">" "</span>+ attrs;

  <span class="comment">// serialize this Element</span>
  ret += <span class="literal">"&lt;"</span> + <span class="reserved">this</span>.nodeName + ns + attrs +<span class="literal">"&gt;"</span>;
  ret += <span class="reserved">this</span>.childNodes.toString();;
  ret += <span class="literal">"&lt;/"</span> + <span class="reserved">this</span>.nodeName+<span class="literal">"&gt;"</span>;

  <span class="reserved">return</span> ret;
}

<span class="comment">/**
 * <span class="attrib">@class</span>  DOMAttr - The Attr interface represents an attribute in an Element object
 *
 * <span class="attrib">@extends</span> DOMNode
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  ownerDocument : DOMDocument - The Document object associated with this node.
 */</span>
DOMAttr = <span class="reserved">function</span>(ownerDocument) {
  <span class="reserved">this</span>._class = addClass(<span class="reserved">this</span>._class, <span class="literal">"DOMAttr"</span>);
  <span class="reserved">this</span>.DOMNode = DOMNode;
  <span class="reserved">this</span>.DOMNode(ownerDocument);

  <span class="reserved">this</span>.name      = <span class="literal">""</span>;                           <span class="comment">// the name of this attribute</span>

  <span class="comment">// If this attribute was explicitly given a value in the original document, this is true; otherwise, it is false.</span>
  <span class="comment">// Note that the implementation is in charge of this attribute, not the user.</span>
  <span class="comment">// If the user changes the value of the attribute (even if it ends up having the same value as the default value)</span>
  <span class="comment">// then the specified flag is automatically flipped to true</span>
  <span class="comment">// (I wish! You will need to use setValue to 'automatically' update specified)</span>
  <span class="reserved">this</span>.specified = false;

  <span class="reserved">this</span>.value     = <span class="literal">""</span>;                           <span class="comment">// the value of the attribute is returned as a string</span>

  <span class="reserved">this</span>.nodeType  = DOMNode.ATTRIBUTE_NODE;

  <span class="reserved">this</span>.ownerElement = null;                      <span class="comment">// set when Attr is added to NamedNodeMap</span>

  <span class="comment">// disable childNodes</span>
  <span class="reserved">this</span>.childNodes = null;
  <span class="reserved">this</span>.attributes = null;
};
DOMAttr.<span class="reserved">prototype</span> = new DOMNode;

<span class="comment">/**
 * <span class="attrib">@method</span> DOMAttr.getName - Java style gettor for .name
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMAttr.<span class="reserved">prototype</span>.getName = <span class="reserved">function</span> DOMAttr_getName() {
  <span class="reserved">return</span> <span class="reserved">this</span>.nodeName;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMAttr.getSpecified - Java style gettor for .specified
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : boolean
 */</span>
DOMAttr.<span class="reserved">prototype</span>.getSpecified = <span class="reserved">function</span> DOMAttr_getSpecified() {
  <span class="reserved">return</span> <span class="reserved">this</span>.specified;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMAttr.getValue - Java style gettor for .value
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMAttr.<span class="reserved">prototype</span>.getValue = <span class="reserved">function</span> DOMAttr_getValue() {
  <span class="reserved">return</span> <span class="reserved">this</span>.nodeValue;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMAttr.setValue - Java style settor for .value
 *   alias for DOMAttr.setNodeValue
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  value : string - the new attribute value
 *
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this Attribute is readonly.
 */</span>
DOMAttr.<span class="reserved">prototype</span>.setValue = <span class="reserved">function</span> DOMAttr_setValue(value) {
  <span class="comment">// throw Exception if Attribute is readonly</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; <span class="reserved">this</span>._readonly) {
    throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
  }

  <span class="comment">// delegate to setNodeValue</span>
  <span class="reserved">this</span>.setNodeValue(value);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMAttr.setNodeValue - Java style settor for .nodeValue
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  value : string - the new attribute value
 */</span>
DOMAttr.<span class="reserved">prototype</span>.setNodeValue = <span class="reserved">function</span> DOMAttr_setNodeValue(value) {
  <span class="reserved">this</span>.nodeValue = new String(value);
  <span class="reserved">this</span>.value     = <span class="reserved">this</span>.nodeValue;
  <span class="reserved">this</span>.specified = (<span class="reserved">this</span>.value.length &gt; 0);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMAttr.toString - Serialize this Attr into an XML string
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au) and David Joham (djoham<span class="attrib">@yahoo</span>.com)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMAttr.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span> DOMAttr_toString() {
  var ret = <span class="literal">""</span>;

  <span class="comment">// serialize Attribute</span>
  ret += <span class="reserved">this</span>.nodeName +<span class="literal">"=\"</span><span class="literal">"+ this.__escapeString(this.nodeValue) +"</span>\<span class="literal">""</span>;

  <span class="reserved">return</span> ret;
}

DOMAttr.<span class="reserved">prototype</span>.getOwnerElement = <span class="reserved">function</span>() {

    <span class="reserved">return</span> <span class="reserved">this</span>.ownerElement;

}

<span class="comment">/**
 * <span class="attrib">@class</span>  DOMNamespace - The Namespace interface represents an namespace in an Element object
 *
 * <span class="attrib">@extends</span> DOMNode
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  ownerDocument : DOMDocument - The Document object associated with this node.
 */</span>
DOMNamespace = <span class="reserved">function</span>(ownerDocument) {
  <span class="reserved">this</span>._class = addClass(<span class="reserved">this</span>._class, <span class="literal">"DOMNamespace"</span>);
  <span class="reserved">this</span>.DOMNode = DOMNode;
  <span class="reserved">this</span>.DOMNode(ownerDocument);

  <span class="reserved">this</span>.name      = <span class="literal">""</span>;                           <span class="comment">// the name of this attribute</span>

  <span class="comment">// If this attribute was explicitly given a value in the original document, this is true; otherwise, it is false.</span>
  <span class="comment">// Note that the implementation is in charge of this attribute, not the user.</span>
  <span class="comment">// If the user changes the value of the attribute (even if it ends up having the same value as the default value)</span>
  <span class="comment">// then the specified flag is automatically flipped to true</span>
  <span class="comment">// (I wish! You will need to use _setValue to 'automatically' update specified)</span>
  <span class="reserved">this</span>.specified = false;

  <span class="reserved">this</span>.value     = <span class="literal">""</span>;                           <span class="comment">// the value of the attribute is returned as a string</span>

  <span class="reserved">this</span>.nodeType  = DOMNode.NAMESPACE_NODE;
};
DOMNamespace.<span class="reserved">prototype</span> = new DOMNode;

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamespace.getValue - Java style gettor for .value
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMNamespace.<span class="reserved">prototype</span>.getValue = <span class="reserved">function</span> DOMNamespace_getValue() {
  <span class="reserved">return</span> <span class="reserved">this</span>.nodeValue;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamespace.setValue - utility function to set value (rather than direct assignment to .value)
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  value : string - the new namespace value
 */</span>
DOMNamespace.<span class="reserved">prototype</span>.setValue = <span class="reserved">function</span> DOMNamespace_setValue(value) {
  <span class="comment">// assign values to properties (and aliases)</span>
  <span class="reserved">this</span>.nodeValue = new String(value);
  <span class="reserved">this</span>.value     = <span class="reserved">this</span>.nodeValue;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMNamespace.toString - Serialize this Attr into an XML string
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMNamespace.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span> DOMNamespace_toString() {
  var ret = <span class="literal">""</span>;

  <span class="comment">// serialize Namespace Declaration</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.nodeName != <span class="literal">""</span>) {
    ret += <span class="reserved">this</span>.nodeName +<span class="literal">"=\"</span><span class="literal">"+ this.__escapeString(this.nodeValue) +"</span>\<span class="literal">""</span>;
  }
  <span class="reserved">else</span> {  <span class="comment">// handle default namespace</span>
    ret += <span class="literal">"xmlns=\"</span><span class="literal">"+ this.__escapeString(this.nodeValue) +"</span>\<span class="literal">""</span>;
  }

  <span class="reserved">return</span> ret;
}

<span class="comment">/**
 * <span class="attrib">@class</span>  DOMCharacterData - parent abstract class for DOMText and DOMComment
 *
 * <span class="attrib">@extends</span> DOMNode
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  ownerDocument : DOMDocument - The Document object associated with this node.
 */</span>
DOMCharacterData = <span class="reserved">function</span>(ownerDocument) {
  <span class="reserved">this</span>._class = addClass(<span class="reserved">this</span>._class, <span class="literal">"DOMCharacterData"</span>);
  <span class="reserved">this</span>.DOMNode  = DOMNode;
  <span class="reserved">this</span>.DOMNode(ownerDocument);

  <span class="reserved">this</span>.data   = <span class="literal">""</span>;
  <span class="reserved">this</span>.length = 0;
};
DOMCharacterData.<span class="reserved">prototype</span> = new DOMNode;

<span class="comment">/**
 * <span class="attrib">@method</span> DOMCharacterData.getData - Java style gettor for .data
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMCharacterData.<span class="reserved">prototype</span>.getData = <span class="reserved">function</span> DOMCharacterData_getData() {
  <span class="reserved">return</span> <span class="reserved">this</span>.nodeValue;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMCharacterData.setData - Java style settor for .data
 *  alias for DOMCharacterData.setNodeValue
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  data : string - the character data
 *
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this Attribute is readonly.
 */</span>
DOMCharacterData.<span class="reserved">prototype</span>.setData = <span class="reserved">function</span> DOMCharacterData_setData(data) {
  <span class="comment">// delegate to setNodeValue</span>
  <span class="reserved">this</span>.setNodeValue(data);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMCharacterData.setNodeValue - Java style settor for .nodeValue
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  data : string - the node value
 *
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this Attribute is readonly.
 */</span>
DOMCharacterData.<span class="reserved">prototype</span>.setNodeValue = <span class="reserved">function</span> DOMCharacterData_setNodeValue(data) {
  <span class="comment">// throw Exception if Attribute is readonly</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; <span class="reserved">this</span>._readonly) {
    throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
  }

  <span class="comment">// assign values to properties (and aliases)</span>
  <span class="reserved">this</span>.nodeValue = new String(data);
  <span class="reserved">this</span>.data   = <span class="reserved">this</span>.nodeValue;

  <span class="comment">// update length</span>
  <span class="reserved">this</span>.length = <span class="reserved">this</span>.nodeValue.length;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMCharacterData.getLength - Java style gettor for .length
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMCharacterData.<span class="reserved">prototype</span>.getLength = <span class="reserved">function</span> DOMCharacterData_getLength() {
  <span class="reserved">return</span> <span class="reserved">this</span>.nodeValue.length;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMCharacterData.substringData - Extracts a range of data from the node
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  offset : int - Start offset of substring to extract
 * <span class="attrib">@param</span>  count  : int - The number of characters to extract
 *
 * <span class="attrib">@throws</span> : DOMException - INDEX_SIZE_ERR: Raised if specified offset is negative or greater than the number of 16-bit units in data,
 *
 * <span class="attrib">@return</span> : string - The specified substring.
 *   If the sum of offset and count exceeds the length, then all characters to the end of the data are returned.
 */</span>
DOMCharacterData.<span class="reserved">prototype</span>.substringData = <span class="reserved">function</span> DOMCharacterData_substringData(offset, count) {
  var ret = null;

  <span class="reserved">if</span> (<span class="reserved">this</span>.data) {
    <span class="comment">// throw Exception if offset is negative or greater than the data length,</span>
    <span class="comment">// or the count is negative</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; ((offset &lt; 0) || (offset &gt; <span class="reserved">this</span>.data.length) || (count &lt; 0))) {
      throw(new DOMException(DOMException.INDEX_SIZE_ERR));
    }

    <span class="comment">// if count is not specified</span>
    <span class="reserved">if</span> (!count) {
      ret = <span class="reserved">this</span>.data.substring(offset); <span class="comment">// default to 'end of string'</span>
    }
    <span class="reserved">else</span> {
      ret = <span class="reserved">this</span>.data.substring(offset, offset + count);
    }
  }

  <span class="reserved">return</span> ret;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMCharacterData.appendData - Append the string to the end of the character data of the node.
 *   Upon success, data provides access to the concatenation of data and the DOMString specified.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  arg : string - The string to append
 *
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this CharacterData is readonly.
 */</span>
DOMCharacterData.<span class="reserved">prototype</span>.appendData    = <span class="reserved">function</span> DOMCharacterData_appendData(arg) {
  <span class="comment">// throw Exception if DOMCharacterData is readonly</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; <span class="reserved">this</span>._readonly) {
    throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
  }

  <span class="comment">// append data</span>
  <span class="reserved">this</span>.setData(<span class="literal">""</span>+ <span class="reserved">this</span>.data + arg);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMCharacterData.insertData - Insert a string at the specified character offset.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  offset : int    - The character offset at which to insert
 * <span class="attrib">@param</span>  arg    : string - The string to insert
 *
 * <span class="attrib">@throws</span> : DOMException - INDEX_SIZE_ERR: Raised if specified offset is negative or greater than the number of 16-bit units in data,
 *   or if the specified count is negative.
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this CharacterData is readonly.
 */</span>
DOMCharacterData.<span class="reserved">prototype</span>.insertData    = <span class="reserved">function</span> DOMCharacterData_insertData(offset, arg) {
  <span class="comment">// throw Exception if DOMCharacterData is readonly</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; <span class="reserved">this</span>._readonly) {
    throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
  }

  <span class="reserved">if</span> (<span class="reserved">this</span>.data) {
    <span class="comment">// throw Exception if offset is negative or greater than the data length,</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; ((offset &lt; 0) || (offset &gt;  <span class="reserved">this</span>.data.length))) {
      throw(new DOMException(DOMException.INDEX_SIZE_ERR));
    }

    <span class="comment">// insert data</span>
    <span class="reserved">this</span>.setData(<span class="reserved">this</span>.data.substring(0, offset).concat(arg, <span class="reserved">this</span>.data.substring(offset)));
  }
  <span class="reserved">else</span> {
    <span class="comment">// throw Exception if offset is negative or greater than the data length,</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; (offset != 0)) {
      throw(new DOMException(DOMException.INDEX_SIZE_ERR));
    }

    <span class="comment">// set data</span>
    <span class="reserved">this</span>.setData(arg);
  }
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMCharacterData.deleteData - Remove a range of characters from the node.
 *   Upon success, data and length reflect the change
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  offset : int - The offset from which to remove characters
 * <span class="attrib">@param</span>  count  : int - The number of characters to delete.
 *   If the sum of offset and count exceeds length then all characters from offset to the end of the data are deleted
 *
 * <span class="attrib">@throws</span> : DOMException - INDEX_SIZE_ERR: Raised if specified offset is negative or greater than the number of 16-bit units in data,
 *   or if the specified count is negative.
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this CharacterData is readonly.
 */</span>
DOMCharacterData.<span class="reserved">prototype</span>.deleteData    = <span class="reserved">function</span> DOMCharacterData_deleteData(offset, count) {
  <span class="comment">// throw Exception if DOMCharacterData is readonly</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; <span class="reserved">this</span>._readonly) {
    throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
  }

  <span class="reserved">if</span> (<span class="reserved">this</span>.data) {
    <span class="comment">// throw Exception if offset is negative or greater than the data length,</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; ((offset &lt; 0) || (offset &gt;  <span class="reserved">this</span>.data.length) || (count &lt; 0))) {
      throw(new DOMException(DOMException.INDEX_SIZE_ERR));
    }

    <span class="comment">// delete data</span>
    <span class="reserved">if</span>(!count || (offset + count) &gt; <span class="reserved">this</span>.data.length) {
      <span class="reserved">this</span>.setData(<span class="reserved">this</span>.data.substring(0, offset));
    }
    <span class="reserved">else</span> {
      <span class="reserved">this</span>.setData(<span class="reserved">this</span>.data.substring(0, offset).concat(<span class="reserved">this</span>.data.substring(offset + count)));
    }
  }
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMCharacterData.replaceData - Replace the characters starting at the specified character offset with the specified string
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  offset : int    - The offset from which to start replacing
 * <span class="attrib">@param</span>  count  : int    - The number of characters to replace.
 *   If the sum of offset and count exceeds length, then all characters to the end of the data are replaced
 * <span class="attrib">@param</span>  arg    : string - The string with which the range must be replaced
 *
 * <span class="attrib">@throws</span> : DOMException - INDEX_SIZE_ERR: Raised if specified offset is negative or greater than the number of 16-bit units in data,
 *   or if the specified count is negative.
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this CharacterData is readonly.
 */</span>
DOMCharacterData.<span class="reserved">prototype</span>.replaceData   = <span class="reserved">function</span> DOMCharacterData_replaceData(offset, count, arg) {
  <span class="comment">// throw Exception if DOMCharacterData is readonly</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; <span class="reserved">this</span>._readonly) {
    throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
  }

  <span class="reserved">if</span> (<span class="reserved">this</span>.data) {
    <span class="comment">// throw Exception if offset is negative or greater than the data length,</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; ((offset &lt; 0) || (offset &gt;  <span class="reserved">this</span>.data.length) || (count &lt; 0))) {
      throw(new DOMException(DOMException.INDEX_SIZE_ERR));
    }

    <span class="comment">// replace data</span>
    <span class="reserved">this</span>.setData(<span class="reserved">this</span>.data.substring(0, offset).concat(arg, <span class="reserved">this</span>.data.substring(offset + count)));
  }
  <span class="reserved">else</span> {
    <span class="comment">// set data</span>
    <span class="reserved">this</span>.setData(arg);
  }
};

<span class="comment">/**
 * <span class="attrib">@class</span>  DOMText - The Text interface represents the textual content (termed character data in XML) of an Element or Attr.
 *   If there is no markup inside an element's content, the text is contained in a single object implementing the Text interface
 *   that is the only child of the element. If there is markup, it is parsed into a list of elements and Text nodes that form the
 *   list of children of the element.
 *
 * <span class="attrib">@extends</span> DOMCharacterData
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  ownerDocument : DOMDocument - The Document object associated with this node.
 */</span>
DOMText = <span class="reserved">function</span>(ownerDocument) {
  <span class="reserved">this</span>._class = addClass(<span class="reserved">this</span>._class, <span class="literal">"DOMText"</span>);
  <span class="reserved">this</span>.DOMCharacterData  = DOMCharacterData;
  <span class="reserved">this</span>.DOMCharacterData(ownerDocument);

  <span class="reserved">this</span>.nodeName  = <span class="literal">"#text"</span>;
  <span class="reserved">this</span>.nodeType  = DOMNode.TEXT_NODE;
};
DOMText.<span class="reserved">prototype</span> = new DOMCharacterData;

<span class="comment">/**
 * <span class="attrib">@method</span> DOMText.splitText - Breaks this Text node into two Text nodes at the specified offset,
 *   keeping both in the tree as siblings. This node then only contains all the content up to the offset point.
 *   And a new Text node, which is inserted as the next sibling of this node, contains all the content at and after the offset point.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  offset : int - The offset at which to split, starting from 0.
 *
 * <span class="attrib">@throws</span> : DOMException - INDEX_SIZE_ERR: Raised if specified offset is negative or greater than the number of 16-bit units in data,
 * <span class="attrib">@throws</span> : DOMException - NO_MODIFICATION_ALLOWED_ERR: Raised if this Text is readonly.
 *
 * <span class="attrib">@return</span> : DOMText - The new Text node
 */</span>
DOMText.<span class="reserved">prototype</span>.splitText = <span class="reserved">function</span> DOMText_splitText(offset) {
  var data, inode;

  <span class="comment">// test for exceptions</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking) {
    <span class="comment">// throw Exception if Node is readonly</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>._readonly) {
      throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
    }

    <span class="comment">// throw Exception if offset is negative or greater than the data length,</span>
    <span class="reserved">if</span> ((offset &lt; 0) || (offset &gt; <span class="reserved">this</span>.data.length)) {
      throw(new DOMException(DOMException.INDEX_SIZE_ERR));
    }
  }

  <span class="reserved">if</span> (<span class="reserved">this</span>.parentNode) {
    <span class="comment">// get remaining string (after offset)</span>
    data  = <span class="reserved">this</span>.substringData(offset);

    <span class="comment">// create new TextNode with remaining string</span>
    inode = <span class="reserved">this</span>.ownerDocument.createTextNode(data);

    <span class="comment">// attach new TextNode</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>.nextSibling) {
      <span class="reserved">this</span>.parentNode.insertBefore(inode, <span class="reserved">this</span>.nextSibling);
    }
    <span class="reserved">else</span> {
      <span class="reserved">this</span>.parentNode.appendChild(inode);
    }

    <span class="comment">// remove remaining string from original TextNode</span>
    <span class="reserved">this</span>.deleteData(offset);
  }

  <span class="reserved">return</span> inode;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMText.toString - Serialize this Text into an XML string
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au) and David Joham (djoham<span class="attrib">@yahoo</span>.com)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMText.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span> DOMText_toString() {
  <span class="reserved">return</span> <span class="reserved">this</span>.__escapeString(<span class="literal">""</span>+ <span class="reserved">this</span>.nodeValue);
}

<span class="comment">/**
 * <span class="attrib">@class</span>  DOMCDATASection - CDATA sections are used to escape blocks of text containing characters that would otherwise be regarded as markup.
 *   The only delimiter that is recognized in a CDATA section is the "\]\]\&gt;" string that ends the CDATA section
 *
 * <span class="attrib">@extends</span> DOMCharacterData
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  ownerDocument : DOMDocument - The Document object associated with this node.
 */</span>
DOMCDATASection = <span class="reserved">function</span>(ownerDocument) {
  <span class="reserved">this</span>._class = addClass(<span class="reserved">this</span>._class, <span class="literal">"DOMCDATASection"</span>);
  <span class="reserved">this</span>.DOMCharacterData  = DOMCharacterData;
  <span class="reserved">this</span>.DOMCharacterData(ownerDocument);

  <span class="reserved">this</span>.nodeName  = <span class="literal">"#cdata-section"</span>;
  <span class="reserved">this</span>.nodeType  = DOMNode.CDATA_SECTION_NODE;
};
DOMCDATASection.<span class="reserved">prototype</span> = new DOMCharacterData;

<span class="comment">/**
 * <span class="attrib">@method</span> DOMCDATASection.splitText - Breaks this CDATASection node into two CDATASection nodes at the specified offset,
 *   keeping both in the tree as siblings. This node then only contains all the content up to the offset point.
 *   And a new CDATASection node, which is inserted as the next sibling of this node, contains all the content at and after the offset point.
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  offset : int - The offset at which to split, starting from 0.
 *
 * <span class="attrib">@return</span> : DOMCDATASection - The new CDATASection node
 */</span>
DOMCDATASection.<span class="reserved">prototype</span>.splitText = <span class="reserved">function</span> DOMCDATASection_splitText(offset) {
  var data, inode;

  <span class="comment">// test for exceptions</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking) {
    <span class="comment">// throw Exception if Node is readonly</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>._readonly) {
      throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
    }

    <span class="comment">// throw Exception if offset is negative or greater than the data length,</span>
    <span class="reserved">if</span> ((offset &lt; 0) || (offset &gt; <span class="reserved">this</span>.data.length)) {
      throw(new DOMException(DOMException.INDEX_SIZE_ERR));
    }
  }

  <span class="reserved">if</span>(<span class="reserved">this</span>.parentNode) {
    <span class="comment">// get remaining string (after offset)</span>
    data  = <span class="reserved">this</span>.substringData(offset);

    <span class="comment">// create new CDATANode with remaining string</span>
    inode = <span class="reserved">this</span>.ownerDocument.createCDATASection(data);

    <span class="comment">// attach new CDATANode</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>.nextSibling) {
      <span class="reserved">this</span>.parentNode.insertBefore(inode, <span class="reserved">this</span>.nextSibling);
    }
    <span class="reserved">else</span> {
      <span class="reserved">this</span>.parentNode.appendChild(inode);
    }

     <span class="comment">// remove remaining string from original CDATANode</span>
    <span class="reserved">this</span>.deleteData(offset);
  }

  <span class="reserved">return</span> inode;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMCDATASection.toString - Serialize this CDATASection into an XML string
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au) and David Joham (djoham<span class="attrib">@yahoo</span>.com)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMCDATASection.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span> DOMCDATASection_toString() {
  var ret = <span class="literal">""</span>;
  <span class="comment">//do NOT unescape the nodeValue string in CDATA sections!</span>
  ret += <span class="literal">"&lt;![CDATA["</span> + <span class="reserved">this</span>.nodeValue + <span class="literal">"\]\]\&gt;"</span>;

  <span class="reserved">return</span> ret;
}

<span class="comment">/**
 * <span class="attrib">@class</span>  DOMComment - This represents the content of a comment, i.e., all the characters between the starting '&lt;!--' and ending '--&gt;'
 *
 * <span class="attrib">@extends</span> DOMCharacterData
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  ownerDocument : DOMDocument - The Document object associated with this node.
 */</span>
DOMComment = <span class="reserved">function</span>(ownerDocument) {
  <span class="reserved">this</span>._class = addClass(<span class="reserved">this</span>._class, <span class="literal">"DOMComment"</span>);
  <span class="reserved">this</span>.DOMCharacterData  = DOMCharacterData;
  <span class="reserved">this</span>.DOMCharacterData(ownerDocument);

  <span class="reserved">this</span>.nodeName  = <span class="literal">"#comment"</span>;
  <span class="reserved">this</span>.nodeType  = DOMNode.COMMENT_NODE;
};
DOMComment.<span class="reserved">prototype</span> = new DOMCharacterData;

<span class="comment">/**
 * <span class="attrib">@method</span> DOMComment.toString - Serialize this Comment into an XML string
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au) and David Joham (djoham<span class="attrib">@yahoo</span>.com)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMComment.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span> DOMComment_toString() {
  var ret = <span class="literal">""</span>;

  ret += <span class="literal">"&lt;!--"</span> + <span class="reserved">this</span>.nodeValue + <span class="literal">"--&gt;"</span>;

  <span class="reserved">return</span> ret;
}

<span class="comment">/**
 * <span class="attrib">@class</span>  DOMProcessingInstruction - The ProcessingInstruction interface represents a "processing instruction",
 *   used in XML as a way to keep processor-specific information in the text of the document
 *
 * <span class="attrib">@extends</span> DOMNode
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  ownerDocument : DOMDocument - The Document object associated with this node.
 */</span>
DOMProcessingInstruction = <span class="reserved">function</span>(ownerDocument) {
  <span class="reserved">this</span>._class = addClass(<span class="reserved">this</span>._class, <span class="literal">"DOMProcessingInstruction"</span>);
  <span class="reserved">this</span>.DOMNode  = DOMNode;
  <span class="reserved">this</span>.DOMNode(ownerDocument);

  <span class="comment">// The target of this processing instruction.</span>
  <span class="comment">// XML defines this as being the first token following the markup that begins the processing instruction.</span>
  <span class="reserved">this</span>.target = <span class="literal">""</span>;

  <span class="comment">// The content of this processing instruction.</span>
  <span class="comment">// This is from the first non white space character after the target to the character immediately preceding the ?&gt;</span>
  <span class="reserved">this</span>.data   = <span class="literal">""</span>;

  <span class="reserved">this</span>.nodeType  = DOMNode.PROCESSING_INSTRUCTION_NODE;
};
DOMProcessingInstruction.<span class="reserved">prototype</span> = new DOMNode;

<span class="comment">/**
 * <span class="attrib">@method</span> DOMProcessingInstruction.getTarget - Java style gettor for .target
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMProcessingInstruction.<span class="reserved">prototype</span>.getTarget = <span class="reserved">function</span> DOMProcessingInstruction_getTarget() {
  <span class="reserved">return</span> <span class="reserved">this</span>.nodeName;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMProcessingInstruction.getData - Java style gettor for .data
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMProcessingInstruction.<span class="reserved">prototype</span>.getData = <span class="reserved">function</span> DOMProcessingInstruction_getData() {
  <span class="reserved">return</span> <span class="reserved">this</span>.nodeValue;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMProcessingInstruction.setData - Java style settor for .data
 *   alias for DOMProcessingInstruction.setNodeValue
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  data : string - The new data of this processing instruction.
 */</span>
DOMProcessingInstruction.<span class="reserved">prototype</span>.setData = <span class="reserved">function</span> DOMProcessingInstruction_setData(data) {
  <span class="comment">// delegate to setNodeValue</span>
  <span class="reserved">this</span>.setNodeValue(data);
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMProcessingInstruction.setNodeValue - Java style settor for .nodeValue
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  data : string - The new data of this processing instruction.
 */</span>
DOMProcessingInstruction.<span class="reserved">prototype</span>.setNodeValue = <span class="reserved">function</span> DOMProcessingInstruction_setNodeValue(data) {
  <span class="comment">// throw Exception if DOMNode is readonly</span>
  <span class="reserved">if</span> (<span class="reserved">this</span>.ownerDocument.implementation.errorChecking &amp;&amp; <span class="reserved">this</span>._readonly) {
    throw(new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR));
  }

  <span class="comment">// assign values to properties (and aliases)</span>
  <span class="reserved">this</span>.nodeValue = new String(data);
  <span class="reserved">this</span>.data = <span class="reserved">this</span>.nodeValue;
};

<span class="comment">/**
 * <span class="attrib">@method</span> DOMProcessingInstruction.toString - Serialize this ProcessingInstruction into an XML string
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au) and David Joham (djoham<span class="attrib">@yahoo</span>.com)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMProcessingInstruction.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span> DOMProcessingInstruction_toString() {
  var ret = <span class="literal">""</span>;

  ret += <span class="literal">"&lt;?"</span> + <span class="reserved">this</span>.nodeName +<span class="literal">" "</span>+ <span class="reserved">this</span>.nodeValue + <span class="literal">" ?&gt;"</span>;

  <span class="reserved">return</span> ret;
}

<span class="comment">/**
 * <span class="attrib">@class</span>  DOMDocumentFragment - DocumentFragment is a "lightweight" or "minimal" Document object.
 *
 * <span class="attrib">@extends</span> DOMNode
 *
 * <span class="attrib">@author</span> Jon van Noort (jon<span class="attrib">@webarcana</span>.com.au)
 *
 * <span class="attrib">@param</span>  ownerDocument : DOMDocument - The Document object associated with this node.
 */</span>
DOMDocumentFragment = <span class="reserved">function</span>(ownerDocument) {
  <span class="reserved">this</span>._class = addClass(<span class="reserved">this</span>._class, <span class="literal">"DOMDocumentFragment"</span>);
  <span class="reserved">this</span>.DOMNode = DOMNode;
  <span class="reserved">this</span>.DOMNode(ownerDocument);

  <span class="reserved">this</span>.nodeName  = <span class="literal">"#document-fragment"</span>;
  <span class="reserved">this</span>.nodeType = DOMNode.DOCUMENT_FRAGMENT_NODE;
};
DOMDocumentFragment.<span class="reserved">prototype</span> = new DOMNode;

<span class="comment">/**
 * <span class="attrib">@method</span> DOMDocumentFragment.toString - Serialize this DocumentFragment into an XML string
 *
 * <span class="attrib">@author</span> David Joham (djoham<span class="attrib">@yahoo</span>.com)
 *
 * <span class="attrib">@return</span> : string
 */</span>
DOMDocumentFragment.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span> DOMDocumentFragment_toString() {
  var xml = <span class="literal">""</span>;
  var intCount = <span class="reserved">this</span>.getChildNodes().getLength();

  <span class="comment">// create string concatenating the serialized ChildNodes</span>
  <span class="reserved">for</span> (intLoop = 0; intLoop &lt; intCount; intLoop++) {
    xml += <span class="reserved">this</span>.getChildNodes().item(intLoop).toString();
  }

  <span class="reserved">return</span> xml;
}

<span class="comment">///////////////////////</span>
<span class="comment">//  NOT IMPLEMENTED  //</span>
<span class="comment">///////////////////////</span>
DOMDocumentType    = <span class="reserved">function</span>() { alert(<span class="literal">"DOMDocumentType.constructor(): Not Implemented"</span>   ); };
DOMEntity          = <span class="reserved">function</span>() { alert(<span class="literal">"DOMEntity.constructor(): Not Implemented"</span>         ); };
DOMEntityReference = <span class="reserved">function</span>() { alert(<span class="literal">"DOMEntityReference.constructor(): Not Implemented"</span>); };
DOMNotation        = <span class="reserved">function</span>() { alert(<span class="literal">"DOMNotation.constructor(): Not Implemented"</span>       ); };


Strings = new Object()
Strings.WHITESPACE = <span class="literal">" \t\n\r"</span>;
Strings.QUOTES = <span class="literal">"\"</span>'<span class="literal">";

Strings.isEmpty = function Strings_isEmpty(strD) {
    return (strD == null) || (strD.length == 0);
};
Strings.indexOfNonWhitespace = function Strings_indexOfNonWhitespace(strD, iB, iE) {
  if(Strings.isEmpty(strD)) return -1;
  iB = iB || 0;
  iE = iE || strD.length;

  for(var i = iB; i &lt; iE; i++)
    if(Strings.WHITESPACE.indexOf(strD.charAt(i)) == -1) {
      return i;
    }
  return -1;
};
Strings.lastIndexOfNonWhitespace = function Strings_lastIndexOfNonWhitespace(strD, iB, iE) {
  if(Strings.isEmpty(strD)) return -1;
  iB = iB || 0;
  iE = iE || strD.length;

  for(var i = iE - 1; i &gt;= iB; i--)
    if(Strings.WHITESPACE.indexOf(strD.charAt(i)) == -1)
      return i;
  return -1;
};
Strings.indexOfWhitespace = function Strings_indexOfWhitespace(strD, iB, iE) {
  if(Strings.isEmpty(strD)) return -1;
  iB = iB || 0;
  iE = iE || strD.length;

  for(var i = iB; i &lt; iE; i++)
    if(Strings.WHITESPACE.indexOf(strD.charAt(i)) != -1)
      return i;
  return -1;
};
Strings.replace = function Strings_replace(strD, iB, iE, strF, strR) {
  if(Strings.isEmpty(strD)) return "</span><span class="literal">";
  iB = iB || 0;
  iE = iE || strD.length;

  return strD.substring(iB, iE).split(strF).join(strR);
};
Strings.getLineNumber = function Strings_getLineNumber(strD, iP) {
  if(Strings.isEmpty(strD)) return -1;
  iP = iP || strD.length;

  return strD.substring(0, iP).split("</span>\n<span class="literal">").length
};
Strings.getColumnNumber = function Strings_getColumnNumber(strD, iP) {
  if(Strings.isEmpty(strD)) return -1;
  iP = iP || strD.length;

  var arrD = strD.substring(0, iP).split("</span>\n<span class="literal">");
  var strLine = arrD[arrD.length - 1];
  arrD.length--;
  var iLinePos = arrD.join("</span>\n<span class="literal">").length;

  return iP - iLinePos;
};


StringBuffer = function() {this._a=new Array();};
StringBuffer.prototype.append = function StringBuffer_append(d){this._a[this._a.length]=d;};
StringBuffer.prototype.toString = function StringBuffer_toString(){return this._a.join("</span>");};
</pre>
	<hr>



<!-- ========== START OF NAVBAR ========== -->
<a name="navbar_top"><!-- --></a>
<table border="0" width="100%" cellpadding="1" cellspacing="0">
<tr>
<td colspan=2 bgcolor="#EEEEFF" class="NavBarCell1">
<a name="navbar_top_firstrow"><!-- --></a>
<table border="0" cellpadding="0" cellspacing="3">
  <tr align="center" valign="top">
  
  
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-summary.html"><font class="NavBarFont1"><b>Overview</b></font></a>&nbsp;</td>
  <td bgcolor="#FFFFFF" class="NavBarCell1Rev">	&nbsp;<font class="NavBarFont1Rev"><b>File</b></font>&nbsp;</td>
  

  <td bgcolor="#FFFFFF" class="NavBarCell1"> <font class="NavBarFont1">Class</font>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-tree.html"><font class="NavBarFont1"><b>Tree</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="index-all.html"--><font class="NavBarFont1"><b>Index</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="help-doc.html"><font class="NavBarFont1"><b>Help</b></font></a>&nbsp;</td>
  </tr>
</table>
</td>
<td bgcolor="#EEEEFF" align="right" valign="top"><em>
<b></b></em>
</td>
</tr>

<tr>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</font></td>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
  <a href="index.html" target="_top"><b>FRAMES</b></a>  &nbsp;
&nbsp;<a href="overview-summary.html" target="_top"><b>NO FRAMES</b></a>
&nbsp;&nbsp;
<script>
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</script>
<noscript>
<a href="allclasses-noframe.html" target=""><b>All Classes</b></a>
</noscript>
</font></td>
</tr>
</table>
<!-- =========== END OF NAVBAR =========== -->

<hr>
<font size="-1">

</font>
<div class="jsdoc_ctime">Documentation generated by <a href="http://jsdoc.sourceforge.net/" target="_parent">JSDoc</a> on Sat Aug  2 22:28:04 2008</div>
</body>
</html>
